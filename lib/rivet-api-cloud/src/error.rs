// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `CompleteUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CompleteUploadError {
	/// Kind of error that occurred.
	pub kind: CompleteUploadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CompleteUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CompleteUploadErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CompleteUploadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CompleteUploadErrorKind::InternalError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CompleteUploadError {
	fn code(&self) -> Option<&str> {
		CompleteUploadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CompleteUploadErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CompleteUploadErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl CompleteUploadError {
	/// Creates a new `CompleteUploadError`.
	pub fn new(kind: CompleteUploadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CompleteUploadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CompleteUploadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CompleteUploadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CompleteUploadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CompleteUploadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CompleteUploadErrorKind::InternalError(_inner) => Some(_inner),
			CompleteUploadErrorKind::RateLimitError(_inner) => Some(_inner),
			CompleteUploadErrorKind::ForbiddenError(_inner) => Some(_inner),
			CompleteUploadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CompleteUploadErrorKind::NotFoundError(_inner) => Some(_inner),
			CompleteUploadErrorKind::BadRequestError(_inner) => Some(_inner),
			CompleteUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ConvertTeam` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConvertTeamError {
	/// Kind of error that occurred.
	pub kind: ConvertTeamErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ConvertTeam` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConvertTeamErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConvertTeamError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ConvertTeamErrorKind::InternalError(_inner) => _inner.fmt(f),
			ConvertTeamErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ConvertTeamErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ConvertTeamErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ConvertTeamErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ConvertTeamErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ConvertTeamErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ConvertTeamError {
	fn code(&self) -> Option<&str> {
		ConvertTeamError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ConvertTeamErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ConvertTeamErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ConvertTeamError {
	/// Creates a new `ConvertTeamError`.
	pub fn new(kind: ConvertTeamErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ConvertTeamError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ConvertTeamErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ConvertTeamError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ConvertTeamErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ConvertTeamErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ConvertTeamErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ConvertTeamErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ConvertTeamErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ConvertTeamErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ConvertTeamErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ConvertTeamErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ConvertTeamErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ConvertTeamErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ConvertTeamErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ConvertTeamErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ConvertTeamErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ConvertTeamError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ConvertTeamErrorKind::InternalError(_inner) => Some(_inner),
			ConvertTeamErrorKind::RateLimitError(_inner) => Some(_inner),
			ConvertTeamErrorKind::ForbiddenError(_inner) => Some(_inner),
			ConvertTeamErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ConvertTeamErrorKind::NotFoundError(_inner) => Some(_inner),
			ConvertTeamErrorKind::BadRequestError(_inner) => Some(_inner),
			ConvertTeamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateCloudToken` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCloudTokenError {
	/// Kind of error that occurred.
	pub kind: CreateCloudTokenErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCloudToken` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCloudTokenErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCloudTokenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateCloudTokenErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCloudTokenError {
	fn code(&self) -> Option<&str> {
		CreateCloudTokenError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateCloudTokenErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateCloudTokenErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateCloudTokenError {
	/// Creates a new `CreateCloudTokenError`.
	pub fn new(kind: CreateCloudTokenErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateCloudTokenError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateCloudTokenErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateCloudTokenError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateCloudTokenErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateCloudTokenError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateCloudTokenErrorKind::InternalError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGame` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameError {
	/// Kind of error that occurred.
	pub kind: CreateGameErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGame` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameError {
	fn code(&self) -> Option<&str> {
		CreateGameError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateGameErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl CreateGameError {
	/// Creates a new `CreateGameError`.
	pub fn new(kind: CreateGameErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameBuild` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameBuildError {
	/// Kind of error that occurred.
	pub kind: CreateGameBuildErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameBuild` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameBuildErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameBuildError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameBuildErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameBuildError {
	fn code(&self) -> Option<&str> {
		CreateGameBuildError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameBuildErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateGameBuildErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameBuildError {
	/// Creates a new `CreateGameBuildError`.
	pub fn new(kind: CreateGameBuildErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameBuildError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameBuildErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameBuildError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameBuildErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameBuildError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameBuildErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameCdnSite` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameCdnSiteError {
	/// Kind of error that occurred.
	pub kind: CreateGameCdnSiteErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameCdnSite` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameCdnSiteErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameCdnSiteError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameCdnSiteErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameCdnSiteError {
	fn code(&self) -> Option<&str> {
		CreateGameCdnSiteError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameCdnSiteErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateGameCdnSiteErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameCdnSiteError {
	/// Creates a new `CreateGameCdnSiteError`.
	pub fn new(kind: CreateGameCdnSiteErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameCdnSiteError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameCdnSiteErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameCdnSiteError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameCdnSiteErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameCdnSiteError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameCdnSiteErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameNamespace` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameNamespaceError {
	/// Kind of error that occurred.
	pub kind: CreateGameNamespaceErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameNamespace` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameNamespaceErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameNamespaceError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameNamespaceErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameNamespaceError {
	fn code(&self) -> Option<&str> {
		CreateGameNamespaceError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameNamespaceErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			CreateGameNamespaceErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameNamespaceError {
	/// Creates a new `CreateGameNamespaceError`.
	pub fn new(kind: CreateGameNamespaceErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameNamespaceError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameNamespaceErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameNamespaceError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameNamespaceErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameNamespaceError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameNamespaceErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameNamespaceTokenDevelopment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameNamespaceTokenDevelopmentError {
	/// Kind of error that occurred.
	pub kind: CreateGameNamespaceTokenDevelopmentErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameNamespaceTokenDevelopment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameNamespaceTokenDevelopmentErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameNamespaceTokenDevelopmentError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameNamespaceTokenDevelopmentErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameNamespaceTokenDevelopmentError {
	fn code(&self) -> Option<&str> {
		CreateGameNamespaceTokenDevelopmentError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameNamespaceTokenDevelopmentErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameNamespaceTokenDevelopmentError {
	/// Creates a new `CreateGameNamespaceTokenDevelopmentError`.
	pub fn new(
		kind: CreateGameNamespaceTokenDevelopmentErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameNamespaceTokenDevelopmentError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameNamespaceTokenDevelopmentErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameNamespaceTokenDevelopmentError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameNamespaceTokenDevelopmentErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for CreateGameNamespaceTokenDevelopmentError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameNamespaceTokenDevelopmentErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `CreateGameNamespaceTokenPublic` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameNamespaceTokenPublicError {
	/// Kind of error that occurred.
	pub kind: CreateGameNamespaceTokenPublicErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameNamespaceTokenPublic` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameNamespaceTokenPublicErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameNamespaceTokenPublicError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameNamespaceTokenPublicErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameNamespaceTokenPublicError {
	fn code(&self) -> Option<&str> {
		CreateGameNamespaceTokenPublicError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameNamespaceTokenPublicErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameNamespaceTokenPublicError {
	/// Creates a new `CreateGameNamespaceTokenPublicError`.
	pub fn new(
		kind: CreateGameNamespaceTokenPublicErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameNamespaceTokenPublicError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameNamespaceTokenPublicErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameNamespaceTokenPublicError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameNamespaceTokenPublicErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for CreateGameNamespaceTokenPublicError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameNamespaceTokenPublicErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameVersionError {
	/// Kind of error that occurred.
	pub kind: CreateGameVersionErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameVersionErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameVersionError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameVersionErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameVersionError {
	fn code(&self) -> Option<&str> {
		CreateGameVersionError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameVersionErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateGameVersionErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameVersionError {
	/// Creates a new `CreateGameVersionError`.
	pub fn new(kind: CreateGameVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameVersionError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameVersionErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameVersionErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameVersionError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameVersionErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `DeleteMatchmakerLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMatchmakerLobbyError {
	/// Kind of error that occurred.
	pub kind: DeleteMatchmakerLobbyErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteMatchmakerLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMatchmakerLobbyErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMatchmakerLobbyError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			DeleteMatchmakerLobbyErrorKind::InternalError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteMatchmakerLobbyError {
	fn code(&self) -> Option<&str> {
		DeleteMatchmakerLobbyError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			DeleteMatchmakerLobbyErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			DeleteMatchmakerLobbyErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl DeleteMatchmakerLobbyError {
	/// Creates a new `DeleteMatchmakerLobbyError`.
	pub fn new(kind: DeleteMatchmakerLobbyErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `DeleteMatchmakerLobbyError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: DeleteMatchmakerLobbyErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `DeleteMatchmakerLobbyError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: DeleteMatchmakerLobbyErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, DeleteMatchmakerLobbyErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			DeleteMatchmakerLobbyErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			DeleteMatchmakerLobbyErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			DeleteMatchmakerLobbyErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, DeleteMatchmakerLobbyErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			DeleteMatchmakerLobbyErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for DeleteMatchmakerLobbyError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			DeleteMatchmakerLobbyErrorKind::InternalError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::RateLimitError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::ForbiddenError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::UnauthorizedError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::NotFoundError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::BadRequestError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ExportMatchmakerLobbyHistory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExportMatchmakerLobbyHistoryError {
	/// Kind of error that occurred.
	pub kind: ExportMatchmakerLobbyHistoryErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ExportMatchmakerLobbyHistory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExportMatchmakerLobbyHistoryErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExportMatchmakerLobbyHistoryError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ExportMatchmakerLobbyHistoryErrorKind::InternalError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ExportMatchmakerLobbyHistoryError {
	fn code(&self) -> Option<&str> {
		ExportMatchmakerLobbyHistoryError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ExportMatchmakerLobbyHistoryErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ExportMatchmakerLobbyHistoryError {
	/// Creates a new `ExportMatchmakerLobbyHistoryError`.
	pub fn new(kind: ExportMatchmakerLobbyHistoryErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ExportMatchmakerLobbyHistoryError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ExportMatchmakerLobbyHistoryErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ExportMatchmakerLobbyHistoryError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ExportMatchmakerLobbyHistoryErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ExportMatchmakerLobbyHistoryError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ExportMatchmakerLobbyHistoryErrorKind::InternalError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::RateLimitError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::NotFoundError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::BadRequestError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameByIdError {
	/// Kind of error that occurred.
	pub kind: GetGameByIdErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameByIdErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameByIdError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameByIdErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameByIdError {
	fn code(&self) -> Option<&str> {
		GetGameByIdError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameByIdErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGameByIdErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetGameByIdError {
	/// Creates a new `GetGameByIdError`.
	pub fn new(kind: GetGameByIdErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameByIdError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameByIdErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameByIdError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameByIdErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGameByIdError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameByIdErrorKind::InternalError(_inner) => Some(_inner),
			GetGameByIdErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameByIdErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameByIdErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameByIdErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameByIdErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameByIdErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameNamespaceById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameNamespaceByIdError {
	/// Kind of error that occurred.
	pub kind: GetGameNamespaceByIdErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameNamespaceById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameNamespaceByIdErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameNamespaceByIdError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameNamespaceByIdErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameNamespaceByIdError {
	fn code(&self) -> Option<&str> {
		GetGameNamespaceByIdError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameNamespaceByIdErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetGameNamespaceByIdErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetGameNamespaceByIdError {
	/// Creates a new `GetGameNamespaceByIdError`.
	pub fn new(kind: GetGameNamespaceByIdErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameNamespaceByIdError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameNamespaceByIdErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameNamespaceByIdError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameNamespaceByIdErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameNamespaceByIdErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameNamespaceByIdErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameNamespaceByIdErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGameNamespaceByIdErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameNamespaceByIdErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGameNamespaceByIdErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GetGameNamespaceByIdError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameNamespaceByIdErrorKind::InternalError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGames` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGamesError {
	/// Kind of error that occurred.
	pub kind: GetGamesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGames` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGamesErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGamesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGamesErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGamesError {
	fn code(&self) -> Option<&str> {
		GetGamesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGamesErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGamesErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetGamesError {
	/// Creates a new `GetGamesError`.
	pub fn new(kind: GetGamesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGamesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGamesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGamesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGamesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGamesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGamesErrorKind::InternalError(_inner) => Some(_inner),
			GetGamesErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGamesErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGamesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGamesErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGamesErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGamesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameVersionById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameVersionByIdError {
	/// Kind of error that occurred.
	pub kind: GetGameVersionByIdErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameVersionById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameVersionByIdErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameVersionByIdError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameVersionByIdErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameVersionByIdError {
	fn code(&self) -> Option<&str> {
		GetGameVersionByIdError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameVersionByIdErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGameVersionByIdErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetGameVersionByIdError {
	/// Creates a new `GetGameVersionByIdError`.
	pub fn new(kind: GetGameVersionByIdErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameVersionByIdError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameVersionByIdErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameVersionByIdError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameVersionByIdErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGameVersionByIdErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGameVersionByIdError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameVersionByIdErrorKind::InternalError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetNamespaceAnalyticsMatchmakerLive` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetNamespaceAnalyticsMatchmakerLiveError {
	/// Kind of error that occurred.
	pub kind: GetNamespaceAnalyticsMatchmakerLiveErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetNamespaceAnalyticsMatchmakerLive` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetNamespaceAnalyticsMatchmakerLiveErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetNamespaceAnalyticsMatchmakerLiveError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetNamespaceAnalyticsMatchmakerLiveError {
	fn code(&self) -> Option<&str> {
		GetNamespaceAnalyticsMatchmakerLiveError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetNamespaceAnalyticsMatchmakerLiveError {
	/// Creates a new `GetNamespaceAnalyticsMatchmakerLiveError`.
	pub fn new(
		kind: GetNamespaceAnalyticsMatchmakerLiveErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetNamespaceAnalyticsMatchmakerLiveError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetNamespaceAnalyticsMatchmakerLiveErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetNamespaceAnalyticsMatchmakerLiveError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetNamespaceAnalyticsMatchmakerLiveErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GetNamespaceAnalyticsMatchmakerLiveError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `GetNamespaceLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetNamespaceLobbyError {
	/// Kind of error that occurred.
	pub kind: GetNamespaceLobbyErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetNamespaceLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetNamespaceLobbyErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetNamespaceLobbyError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetNamespaceLobbyErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetNamespaceLobbyError {
	fn code(&self) -> Option<&str> {
		GetNamespaceLobbyError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetNamespaceLobbyErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetNamespaceLobbyErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetNamespaceLobbyError {
	/// Creates a new `GetNamespaceLobbyError`.
	pub fn new(kind: GetNamespaceLobbyErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetNamespaceLobbyError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetNamespaceLobbyErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetNamespaceLobbyError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetNamespaceLobbyErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetNamespaceLobbyError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetNamespaceLobbyErrorKind::InternalError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::RateLimitError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::NotFoundError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::BadRequestError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetRayPerfLogs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRayPerfLogsError {
	/// Kind of error that occurred.
	pub kind: GetRayPerfLogsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetRayPerfLogs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRayPerfLogsErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRayPerfLogsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetRayPerfLogsErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRayPerfLogsError {
	fn code(&self) -> Option<&str> {
		GetRayPerfLogsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetRayPerfLogsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetRayPerfLogsErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetRayPerfLogsError {
	/// Creates a new `GetRayPerfLogsError`.
	pub fn new(kind: GetRayPerfLogsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetRayPerfLogsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetRayPerfLogsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetRayPerfLogsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetRayPerfLogsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetRayPerfLogsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetRayPerfLogsErrorKind::InternalError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::RateLimitError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::NotFoundError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::BadRequestError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetRegionTiers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRegionTiersError {
	/// Kind of error that occurred.
	pub kind: GetRegionTiersErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetRegionTiers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRegionTiersErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRegionTiersError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetRegionTiersErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRegionTiersError {
	fn code(&self) -> Option<&str> {
		GetRegionTiersError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetRegionTiersErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetRegionTiersErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetRegionTiersError {
	/// Creates a new `GetRegionTiersError`.
	pub fn new(kind: GetRegionTiersErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetRegionTiersError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetRegionTiersErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetRegionTiersError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetRegionTiersErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetRegionTiersError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetRegionTiersErrorKind::InternalError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::RateLimitError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::NotFoundError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::BadRequestError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetTeamBilling` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTeamBillingError {
	/// Kind of error that occurred.
	pub kind: GetTeamBillingErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTeamBilling` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTeamBillingErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTeamBillingError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetTeamBillingErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetTeamBillingErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetTeamBillingErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetTeamBillingErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetTeamBillingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetTeamBillingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetTeamBillingErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTeamBillingError {
	fn code(&self) -> Option<&str> {
		GetTeamBillingError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetTeamBillingErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetTeamBillingErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetTeamBillingError {
	/// Creates a new `GetTeamBillingError`.
	pub fn new(kind: GetTeamBillingErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetTeamBillingError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetTeamBillingErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetTeamBillingError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetTeamBillingErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetTeamBillingErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetTeamBillingErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetTeamBillingErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetTeamBillingErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetTeamBillingErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetTeamBillingErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetTeamBillingErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetTeamBillingErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetTeamBillingErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetTeamBillingErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetTeamBillingErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetTeamBillingErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetTeamBillingError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetTeamBillingErrorKind::InternalError(_inner) => Some(_inner),
			GetTeamBillingErrorKind::RateLimitError(_inner) => Some(_inner),
			GetTeamBillingErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetTeamBillingErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetTeamBillingErrorKind::NotFoundError(_inner) => Some(_inner),
			GetTeamBillingErrorKind::BadRequestError(_inner) => Some(_inner),
			GetTeamBillingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetTeamPaymentsList` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTeamPaymentsListError {
	/// Kind of error that occurred.
	pub kind: GetTeamPaymentsListErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTeamPaymentsList` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTeamPaymentsListErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTeamPaymentsListError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetTeamPaymentsListErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetTeamPaymentsListErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetTeamPaymentsListErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetTeamPaymentsListErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetTeamPaymentsListErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetTeamPaymentsListErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetTeamPaymentsListErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTeamPaymentsListError {
	fn code(&self) -> Option<&str> {
		GetTeamPaymentsListError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetTeamPaymentsListErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetTeamPaymentsListErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetTeamPaymentsListError {
	/// Creates a new `GetTeamPaymentsListError`.
	pub fn new(kind: GetTeamPaymentsListErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetTeamPaymentsListError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetTeamPaymentsListErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetTeamPaymentsListError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetTeamPaymentsListErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetTeamPaymentsListErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetTeamPaymentsListErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetTeamPaymentsListErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetTeamPaymentsListErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetTeamPaymentsListErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetTeamPaymentsListErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetTeamPaymentsListErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetTeamPaymentsListErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetTeamPaymentsListErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetTeamPaymentsListErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetTeamPaymentsListErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetTeamPaymentsListErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetTeamPaymentsListError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetTeamPaymentsListErrorKind::InternalError(_inner) => Some(_inner),
			GetTeamPaymentsListErrorKind::RateLimitError(_inner) => Some(_inner),
			GetTeamPaymentsListErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetTeamPaymentsListErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetTeamPaymentsListErrorKind::NotFoundError(_inner) => Some(_inner),
			GetTeamPaymentsListErrorKind::BadRequestError(_inner) => Some(_inner),
			GetTeamPaymentsListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetTeamTransfersList` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTeamTransfersListError {
	/// Kind of error that occurred.
	pub kind: GetTeamTransfersListErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTeamTransfersList` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTeamTransfersListErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTeamTransfersListError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetTeamTransfersListErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetTeamTransfersListErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetTeamTransfersListErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetTeamTransfersListErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetTeamTransfersListErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetTeamTransfersListErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetTeamTransfersListErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTeamTransfersListError {
	fn code(&self) -> Option<&str> {
		GetTeamTransfersListError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetTeamTransfersListErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetTeamTransfersListErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetTeamTransfersListError {
	/// Creates a new `GetTeamTransfersListError`.
	pub fn new(kind: GetTeamTransfersListErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetTeamTransfersListError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetTeamTransfersListErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetTeamTransfersListError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetTeamTransfersListErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetTeamTransfersListErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetTeamTransfersListErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetTeamTransfersListErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetTeamTransfersListErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetTeamTransfersListErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetTeamTransfersListErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetTeamTransfersListErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetTeamTransfersListErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetTeamTransfersListErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetTeamTransfersListErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetTeamTransfersListErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GetTeamTransfersListErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GetTeamTransfersListError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetTeamTransfersListErrorKind::InternalError(_inner) => Some(_inner),
			GetTeamTransfersListErrorKind::RateLimitError(_inner) => Some(_inner),
			GetTeamTransfersListErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetTeamTransfersListErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetTeamTransfersListErrorKind::NotFoundError(_inner) => Some(_inner),
			GetTeamTransfersListErrorKind::BadRequestError(_inner) => Some(_inner),
			GetTeamTransfersListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `Inspect` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InspectError {
	/// Kind of error that occurred.
	pub kind: InspectErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `Inspect` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InspectErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InspectError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			InspectErrorKind::InternalError(_inner) => _inner.fmt(f),
			InspectErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			InspectErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			InspectErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			InspectErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			InspectErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			InspectErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for InspectError {
	fn code(&self) -> Option<&str> {
		InspectError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			InspectErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			InspectErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl InspectError {
	/// Creates a new `InspectError`.
	pub fn new(kind: InspectErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `InspectError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: InspectErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `InspectError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: InspectErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `InspectErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for InspectError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			InspectErrorKind::InternalError(_inner) => Some(_inner),
			InspectErrorKind::RateLimitError(_inner) => Some(_inner),
			InspectErrorKind::ForbiddenError(_inner) => Some(_inner),
			InspectErrorKind::UnauthorizedError(_inner) => Some(_inner),
			InspectErrorKind::NotFoundError(_inner) => Some(_inner),
			InspectErrorKind::BadRequestError(_inner) => Some(_inner),
			InspectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListGameBuilds` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGameBuildsError {
	/// Kind of error that occurred.
	pub kind: ListGameBuildsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListGameBuilds` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGameBuildsErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGameBuildsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListGameBuildsErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListGameBuildsError {
	fn code(&self) -> Option<&str> {
		ListGameBuildsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListGameBuildsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListGameBuildsErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ListGameBuildsError {
	/// Creates a new `ListGameBuildsError`.
	pub fn new(kind: ListGameBuildsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListGameBuildsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListGameBuildsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListGameBuildsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListGameBuildsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListGameBuildsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListGameBuildsErrorKind::InternalError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::RateLimitError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::NotFoundError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::BadRequestError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListGameCdnSites` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGameCdnSitesError {
	/// Kind of error that occurred.
	pub kind: ListGameCdnSitesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListGameCdnSites` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGameCdnSitesErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGameCdnSitesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListGameCdnSitesErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListGameCdnSitesError {
	fn code(&self) -> Option<&str> {
		ListGameCdnSitesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListGameCdnSitesErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListGameCdnSitesErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ListGameCdnSitesError {
	/// Creates a new `ListGameCdnSitesError`.
	pub fn new(kind: ListGameCdnSitesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListGameCdnSitesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListGameCdnSitesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListGameCdnSitesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListGameCdnSitesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListGameCdnSitesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListGameCdnSitesErrorKind::InternalError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::RateLimitError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::NotFoundError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::BadRequestError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListNamespaceLobbies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListNamespaceLobbiesError {
	/// Kind of error that occurred.
	pub kind: ListNamespaceLobbiesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListNamespaceLobbies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListNamespaceLobbiesErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListNamespaceLobbiesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListNamespaceLobbiesErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListNamespaceLobbiesError {
	fn code(&self) -> Option<&str> {
		ListNamespaceLobbiesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListNamespaceLobbiesErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ListNamespaceLobbiesErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ListNamespaceLobbiesError {
	/// Creates a new `ListNamespaceLobbiesError`.
	pub fn new(kind: ListNamespaceLobbiesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListNamespaceLobbiesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListNamespaceLobbiesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListNamespaceLobbiesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListNamespaceLobbiesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListNamespaceLobbiesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListNamespaceLobbiesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListNamespaceLobbiesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ListNamespaceLobbiesErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListNamespaceLobbiesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ListNamespaceLobbiesErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ListNamespaceLobbiesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListNamespaceLobbiesErrorKind::InternalError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::RateLimitError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::NotFoundError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::BadRequestError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `RemoveNamespaceDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveNamespaceDomainError {
	/// Kind of error that occurred.
	pub kind: RemoveNamespaceDomainErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RemoveNamespaceDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveNamespaceDomainErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveNamespaceDomainError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			RemoveNamespaceDomainErrorKind::InternalError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveNamespaceDomainError {
	fn code(&self) -> Option<&str> {
		RemoveNamespaceDomainError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			RemoveNamespaceDomainErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			RemoveNamespaceDomainErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl RemoveNamespaceDomainError {
	/// Creates a new `RemoveNamespaceDomainError`.
	pub fn new(kind: RemoveNamespaceDomainErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `RemoveNamespaceDomainError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: RemoveNamespaceDomainErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `RemoveNamespaceDomainError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: RemoveNamespaceDomainErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, RemoveNamespaceDomainErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceDomainErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceDomainErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceDomainErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, RemoveNamespaceDomainErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceDomainErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for RemoveNamespaceDomainError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			RemoveNamespaceDomainErrorKind::InternalError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::RateLimitError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::ForbiddenError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::UnauthorizedError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::NotFoundError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::BadRequestError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `TeamBillingCheckout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TeamBillingCheckoutError {
	/// Kind of error that occurred.
	pub kind: TeamBillingCheckoutErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TeamBillingCheckout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TeamBillingCheckoutErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TeamBillingCheckoutError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			TeamBillingCheckoutErrorKind::InternalError(_inner) => _inner.fmt(f),
			TeamBillingCheckoutErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			TeamBillingCheckoutErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			TeamBillingCheckoutErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			TeamBillingCheckoutErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			TeamBillingCheckoutErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			TeamBillingCheckoutErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for TeamBillingCheckoutError {
	fn code(&self) -> Option<&str> {
		TeamBillingCheckoutError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			TeamBillingCheckoutErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			TeamBillingCheckoutErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl TeamBillingCheckoutError {
	/// Creates a new `TeamBillingCheckoutError`.
	pub fn new(kind: TeamBillingCheckoutErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `TeamBillingCheckoutError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: TeamBillingCheckoutErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `TeamBillingCheckoutError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: TeamBillingCheckoutErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `TeamBillingCheckoutErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, TeamBillingCheckoutErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `TeamBillingCheckoutErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, TeamBillingCheckoutErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `TeamBillingCheckoutErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, TeamBillingCheckoutErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `TeamBillingCheckoutErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			TeamBillingCheckoutErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `TeamBillingCheckoutErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, TeamBillingCheckoutErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `TeamBillingCheckoutErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, TeamBillingCheckoutErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for TeamBillingCheckoutError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			TeamBillingCheckoutErrorKind::InternalError(_inner) => Some(_inner),
			TeamBillingCheckoutErrorKind::RateLimitError(_inner) => Some(_inner),
			TeamBillingCheckoutErrorKind::ForbiddenError(_inner) => Some(_inner),
			TeamBillingCheckoutErrorKind::UnauthorizedError(_inner) => Some(_inner),
			TeamBillingCheckoutErrorKind::NotFoundError(_inner) => Some(_inner),
			TeamBillingCheckoutErrorKind::BadRequestError(_inner) => Some(_inner),
			TeamBillingCheckoutErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ToggleNamespaceDomainPublicAuth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ToggleNamespaceDomainPublicAuthError {
	/// Kind of error that occurred.
	pub kind: ToggleNamespaceDomainPublicAuthErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ToggleNamespaceDomainPublicAuth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ToggleNamespaceDomainPublicAuthErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ToggleNamespaceDomainPublicAuthError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ToggleNamespaceDomainPublicAuthErrorKind::InternalError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ToggleNamespaceDomainPublicAuthError {
	fn code(&self) -> Option<&str> {
		ToggleNamespaceDomainPublicAuthError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ToggleNamespaceDomainPublicAuthErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ToggleNamespaceDomainPublicAuthError {
	/// Creates a new `ToggleNamespaceDomainPublicAuthError`.
	pub fn new(
		kind: ToggleNamespaceDomainPublicAuthErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ToggleNamespaceDomainPublicAuthError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ToggleNamespaceDomainPublicAuthErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ToggleNamespaceDomainPublicAuthError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ToggleNamespaceDomainPublicAuthErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ToggleNamespaceDomainPublicAuthError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ToggleNamespaceDomainPublicAuthErrorKind::InternalError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `UpdateGameNamespaceMatchmakerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGameNamespaceMatchmakerConfigError {
	/// Kind of error that occurred.
	pub kind: UpdateGameNamespaceMatchmakerConfigErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateGameNamespaceMatchmakerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGameNamespaceMatchmakerConfigErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGameNamespaceMatchmakerConfigError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateGameNamespaceMatchmakerConfigError {
	fn code(&self) -> Option<&str> {
		UpdateGameNamespaceMatchmakerConfigError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UpdateGameNamespaceMatchmakerConfigError {
	/// Creates a new `UpdateGameNamespaceMatchmakerConfigError`.
	pub fn new(
		kind: UpdateGameNamespaceMatchmakerConfigErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UpdateGameNamespaceMatchmakerConfigError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UpdateGameNamespaceMatchmakerConfigErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UpdateGameNamespaceMatchmakerConfigError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UpdateGameNamespaceMatchmakerConfigErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for UpdateGameNamespaceMatchmakerConfigError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `UpdateGameNamespaceVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGameNamespaceVersionError {
	/// Kind of error that occurred.
	pub kind: UpdateGameNamespaceVersionErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateGameNamespaceVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGameNamespaceVersionErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGameNamespaceVersionError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UpdateGameNamespaceVersionErrorKind::InternalError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateGameNamespaceVersionError {
	fn code(&self) -> Option<&str> {
		UpdateGameNamespaceVersionError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UpdateGameNamespaceVersionErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			UpdateGameNamespaceVersionErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UpdateGameNamespaceVersionError {
	/// Creates a new `UpdateGameNamespaceVersionError`.
	pub fn new(kind: UpdateGameNamespaceVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UpdateGameNamespaceVersionError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UpdateGameNamespaceVersionErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UpdateGameNamespaceVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UpdateGameNamespaceVersionErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for UpdateGameNamespaceVersionError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UpdateGameNamespaceVersionErrorKind::InternalError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::RateLimitError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::ForbiddenError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::NotFoundError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::BadRequestError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `UpdateNamespaceDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateNamespaceDomainError {
	/// Kind of error that occurred.
	pub kind: UpdateNamespaceDomainErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateNamespaceDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateNamespaceDomainErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateNamespaceDomainError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UpdateNamespaceDomainErrorKind::InternalError(_inner) => _inner.fmt(f),
			UpdateNamespaceDomainErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UpdateNamespaceDomainErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UpdateNamespaceDomainErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			UpdateNamespaceDomainErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UpdateNamespaceDomainErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UpdateNamespaceDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateNamespaceDomainError {
	fn code(&self) -> Option<&str> {
		UpdateNamespaceDomainError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UpdateNamespaceDomainErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			UpdateNamespaceDomainErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UpdateNamespaceDomainError {
	/// Creates a new `UpdateNamespaceDomainError`.
	pub fn new(kind: UpdateNamespaceDomainErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UpdateNamespaceDomainError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UpdateNamespaceDomainErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UpdateNamespaceDomainError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UpdateNamespaceDomainErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UpdateNamespaceDomainErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, UpdateNamespaceDomainErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `UpdateNamespaceDomainErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceDomainErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateNamespaceDomainErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceDomainErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateNamespaceDomainErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceDomainErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateNamespaceDomainErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, UpdateNamespaceDomainErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `UpdateNamespaceDomainErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceDomainErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for UpdateNamespaceDomainError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UpdateNamespaceDomainErrorKind::InternalError(_inner) => Some(_inner),
			UpdateNamespaceDomainErrorKind::RateLimitError(_inner) => Some(_inner),
			UpdateNamespaceDomainErrorKind::ForbiddenError(_inner) => Some(_inner),
			UpdateNamespaceDomainErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UpdateNamespaceDomainErrorKind::NotFoundError(_inner) => Some(_inner),
			UpdateNamespaceDomainErrorKind::BadRequestError(_inner) => Some(_inner),
			UpdateNamespaceDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateGame` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameError {
	/// Kind of error that occurred.
	pub kind: ValidateGameErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGame` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameError {
	fn code(&self) -> Option<&str> {
		ValidateGameError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ValidateGameErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ValidateGameError {
	/// Creates a new `ValidateGameError`.
	pub fn new(kind: ValidateGameErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ValidateGameError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateGameErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateGameNamespace` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameNamespaceError {
	/// Kind of error that occurred.
	pub kind: ValidateGameNamespaceErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGameNamespace` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameNamespaceErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameNamespaceError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameNamespaceErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameNamespaceError {
	fn code(&self) -> Option<&str> {
		ValidateGameNamespaceError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameNamespaceErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateGameNamespaceErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateGameNamespaceError {
	/// Creates a new `ValidateGameNamespaceError`.
	pub fn new(kind: ValidateGameNamespaceErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameNamespaceError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameNamespaceErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameNamespaceError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameNamespaceErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ValidateGameNamespaceErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ValidateGameNamespaceErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ValidateGameNamespaceError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameNamespaceErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateGameNamespaceMatchmakerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameNamespaceMatchmakerConfigError {
	/// Kind of error that occurred.
	pub kind: ValidateGameNamespaceMatchmakerConfigErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGameNamespaceMatchmakerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameNamespaceMatchmakerConfigErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameNamespaceMatchmakerConfigError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_inner) => {
				_inner.fmt(f)
			}
			ValidateGameNamespaceMatchmakerConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameNamespaceMatchmakerConfigError {
	fn code(&self) -> Option<&str> {
		ValidateGameNamespaceMatchmakerConfigError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateGameNamespaceMatchmakerConfigError {
	/// Creates a new `ValidateGameNamespaceMatchmakerConfigError`.
	pub fn new(
		kind: ValidateGameNamespaceMatchmakerConfigErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameNamespaceMatchmakerConfigError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameNamespaceMatchmakerConfigErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameNamespaceMatchmakerConfigError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameNamespaceMatchmakerConfigErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ValidateGameNamespaceMatchmakerConfigError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_inner) => {
				Some(_inner)
			}
			ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `ValidateGameNamespaceTokenDevelopment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameNamespaceTokenDevelopmentError {
	/// Kind of error that occurred.
	pub kind: ValidateGameNamespaceTokenDevelopmentErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGameNamespaceTokenDevelopment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameNamespaceTokenDevelopmentErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameNamespaceTokenDevelopmentError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_inner) => {
				_inner.fmt(f)
			}
			ValidateGameNamespaceTokenDevelopmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameNamespaceTokenDevelopmentError {
	fn code(&self) -> Option<&str> {
		ValidateGameNamespaceTokenDevelopmentError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateGameNamespaceTokenDevelopmentError {
	/// Creates a new `ValidateGameNamespaceTokenDevelopmentError`.
	pub fn new(
		kind: ValidateGameNamespaceTokenDevelopmentErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameNamespaceTokenDevelopmentError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameNamespaceTokenDevelopmentErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameNamespaceTokenDevelopmentError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameNamespaceTokenDevelopmentErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ValidateGameNamespaceTokenDevelopmentError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_inner) => {
				Some(_inner)
			}
			ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `ValidateGameVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameVersionError {
	/// Kind of error that occurred.
	pub kind: ValidateGameVersionErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGameVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameVersionErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameVersionError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameVersionErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameVersionError {
	fn code(&self) -> Option<&str> {
		ValidateGameVersionError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameVersionErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateGameVersionErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateGameVersionError {
	/// Creates a new `ValidateGameVersionError`.
	pub fn new(kind: ValidateGameVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameVersionError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameVersionErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameVersionErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameVersionErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ValidateGameVersionError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameVersionErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateTeam` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateTeamError {
	/// Kind of error that occurred.
	pub kind: ValidateTeamErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateTeam` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateTeamErrorKind {
	#[allow(missing_docs)] // documentation missing in model
	InternalError(crate::error::InternalError),
	#[allow(missing_docs)] // documentation missing in model
	RateLimitError(crate::error::RateLimitError),
	#[allow(missing_docs)] // documentation missing in model
	ForbiddenError(crate::error::ForbiddenError),
	#[allow(missing_docs)] // documentation missing in model
	UnauthorizedError(crate::error::UnauthorizedError),
	#[allow(missing_docs)] // documentation missing in model
	NotFoundError(crate::error::NotFoundError),
	#[allow(missing_docs)] // documentation missing in model
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateTeamError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateTeamErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateTeamErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateTeamErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateTeamErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateTeamErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateTeamErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateTeamErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateTeamError {
	fn code(&self) -> Option<&str> {
		ValidateTeamError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateTeamErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ValidateTeamErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ValidateTeamError {
	/// Creates a new `ValidateTeamError`.
	pub fn new(kind: ValidateTeamErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateTeamError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateTeamErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateTeamError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateTeamErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateTeamErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ValidateTeamErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ValidateTeamErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ValidateTeamErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ValidateTeamErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ValidateTeamErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ValidateTeamErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ValidateTeamErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ValidateTeamErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ValidateTeamErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ValidateTeamErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ValidateTeamErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ValidateTeamError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateTeamErrorKind::InternalError(_inner) => Some(_inner),
			ValidateTeamErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateTeamErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateTeamErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateTeamErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateTeamErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateTeamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
}
impl BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
}
impl std::fmt::Debug for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("BadRequestError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.finish()
	}
}
impl BadRequestError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "BadRequestError")?;
		if let Some(inner_1) = &self.message {
			write!(f, ": {}", inner_1)?;
		}
		Ok(())
	}
}
impl std::error::Error for BadRequestError {}
/// See [`BadRequestError`](crate::error::BadRequestError)
pub mod bad_request_error {
	/// A builder for [`BadRequestError`](crate::error::BadRequestError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		/// Consumes the builder and constructs a [`BadRequestError`](crate::error::BadRequestError)
		pub fn build(self) -> crate::error::BadRequestError {
			crate::error::BadRequestError {
				code: self.code,
				message: self.message,
			}
		}
	}
}
impl BadRequestError {
	/// Creates a new builder-style object to manufacture [`BadRequestError`](crate::error::BadRequestError)
	pub fn builder() -> crate::error::bad_request_error::Builder {
		crate::error::bad_request_error::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
}
impl NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
}
impl std::fmt::Debug for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("NotFoundError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.finish()
	}
}
impl NotFoundError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "NotFoundError")?;
		if let Some(inner_2) = &self.message {
			write!(f, ": {}", inner_2)?;
		}
		Ok(())
	}
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
	/// A builder for [`NotFoundError`](crate::error::NotFoundError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		/// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
		pub fn build(self) -> crate::error::NotFoundError {
			crate::error::NotFoundError {
				code: self.code,
				message: self.message,
			}
		}
	}
}
impl NotFoundError {
	/// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
	pub fn builder() -> crate::error::not_found_error::Builder {
		crate::error::not_found_error::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
}
impl UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
}
impl std::fmt::Debug for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnauthorizedError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.finish()
	}
}
impl UnauthorizedError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ClientError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "UnauthorizedError")?;
		if let Some(inner_3) = &self.message {
			write!(f, ": {}", inner_3)?;
		}
		Ok(())
	}
}
impl std::error::Error for UnauthorizedError {}
/// See [`UnauthorizedError`](crate::error::UnauthorizedError)
pub mod unauthorized_error {
	/// A builder for [`UnauthorizedError`](crate::error::UnauthorizedError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		/// Consumes the builder and constructs a [`UnauthorizedError`](crate::error::UnauthorizedError)
		pub fn build(self) -> crate::error::UnauthorizedError {
			crate::error::UnauthorizedError {
				code: self.code,
				message: self.message,
			}
		}
	}
}
impl UnauthorizedError {
	/// Creates a new builder-style object to manufacture [`UnauthorizedError`](crate::error::UnauthorizedError)
	pub fn builder() -> crate::error::unauthorized_error::Builder {
		crate::error::unauthorized_error::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
}
impl ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
}
impl std::fmt::Debug for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ForbiddenError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.finish()
	}
}
impl ForbiddenError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "ForbiddenError")?;
		if let Some(inner_4) = &self.message {
			write!(f, ": {}", inner_4)?;
		}
		Ok(())
	}
}
impl std::error::Error for ForbiddenError {}
/// See [`ForbiddenError`](crate::error::ForbiddenError)
pub mod forbidden_error {
	/// A builder for [`ForbiddenError`](crate::error::ForbiddenError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		/// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError)
		pub fn build(self) -> crate::error::ForbiddenError {
			crate::error::ForbiddenError {
				code: self.code,
				message: self.message,
			}
		}
	}
}
impl ForbiddenError {
	/// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError)
	pub fn builder() -> crate::error::forbidden_error::Builder {
		crate::error::forbidden_error::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
}
impl RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
}
impl std::fmt::Debug for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RateLimitError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.finish()
	}
}
impl RateLimitError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "RateLimitError")?;
		if let Some(inner_5) = &self.message {
			write!(f, ": {}", inner_5)?;
		}
		Ok(())
	}
}
impl std::error::Error for RateLimitError {}
/// See [`RateLimitError`](crate::error::RateLimitError)
pub mod rate_limit_error {
	/// A builder for [`RateLimitError`](crate::error::RateLimitError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		/// Consumes the builder and constructs a [`RateLimitError`](crate::error::RateLimitError)
		pub fn build(self) -> crate::error::RateLimitError {
			crate::error::RateLimitError {
				code: self.code,
				message: self.message,
			}
		}
	}
}
impl RateLimitError {
	/// Creates a new builder-style object to manufacture [`RateLimitError`](crate::error::RateLimitError)
	pub fn builder() -> crate::error::rate_limit_error::Builder {
		crate::error::rate_limit_error::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
}
impl InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
}
impl std::fmt::Debug for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("InternalError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.finish()
	}
}
impl InternalError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ServerError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "InternalError")?;
		if let Some(inner_6) = &self.message {
			write!(f, ": {}", inner_6)?;
		}
		Ok(())
	}
}
impl std::error::Error for InternalError {}
/// See [`InternalError`](crate::error::InternalError)
pub mod internal_error {
	/// A builder for [`InternalError`](crate::error::InternalError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		/// Consumes the builder and constructs a [`InternalError`](crate::error::InternalError)
		pub fn build(self) -> crate::error::InternalError {
			crate::error::InternalError {
				code: self.code,
				message: self.message,
			}
		}
	}
}
impl InternalError {
	/// Creates a new builder-style object to manufacture [`InternalError`](crate::error::InternalError)
	pub fn builder() -> crate::error::internal_error::Builder {
		crate::error::internal_error::Builder::default()
	}
}
