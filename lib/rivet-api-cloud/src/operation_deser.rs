// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_upload_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CompleteUploadOutput, crate::error::CompleteUploadError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CompleteUploadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CompleteUploadError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CompleteUploadError {
			meta: generic,
			kind: crate::error::CompleteUploadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CompleteUploadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CompleteUploadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_upload_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CompleteUploadOutput, crate::error::CompleteUploadError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::complete_upload_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_convert_team_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ConvertTeamOutput, crate::error::ConvertTeamError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ConvertTeamError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ConvertTeamError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ConvertTeamError {
			meta: generic,
			kind: crate::error::ConvertTeamErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ConvertTeamError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ConvertTeamError {
				meta: generic,
				kind: crate::error::ConvertTeamErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ConvertTeamError {
				meta: generic,
				kind: crate::error::ConvertTeamErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ConvertTeamError {
				meta: generic,
				kind: crate::error::ConvertTeamErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ConvertTeamError {
				meta: generic,
				kind: crate::error::ConvertTeamErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ConvertTeamError {
				meta: generic,
				kind: crate::error::ConvertTeamErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ConvertTeamError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_convert_team_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ConvertTeamOutput, crate::error::ConvertTeamError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::convert_team_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cloud_token_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCloudTokenOutput, crate::error::CreateCloudTokenError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateCloudTokenError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateCloudTokenError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateCloudTokenError {
			meta: generic,
			kind: crate::error::CreateCloudTokenErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateCloudTokenError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateCloudTokenError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cloud_token_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCloudTokenOutput, crate::error::CreateCloudTokenError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_cloud_token_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_cloud_token(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateCloudTokenError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameOutput, crate::error::CreateGameError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameError {
			meta: generic,
			kind: crate::error::CreateGameErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameOutput, crate::error::CreateGameError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_build_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameBuildOutput, crate::error::CreateGameBuildError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameBuildError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameBuildError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameBuildError {
			meta: generic,
			kind: crate::error::CreateGameBuildErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameBuildError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameBuildError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_build_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameBuildOutput, crate::error::CreateGameBuildError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_build_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_build(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameBuildError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_cdn_site_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameCdnSiteOutput, crate::error::CreateGameCdnSiteError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameCdnSiteError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameCdnSiteError {
			meta: generic,
			kind: crate::error::CreateGameCdnSiteErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameCdnSiteError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_cdn_site_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameCdnSiteOutput, crate::error::CreateGameCdnSiteError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_cdn_site_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_cdn_site(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceOutput,
	crate::error::CreateGameNamespaceError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameNamespaceError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameNamespaceError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameNamespaceError {
			meta: generic,
			kind: crate::error::CreateGameNamespaceErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameNamespaceError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameNamespaceError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceOutput,
	crate::error::CreateGameNamespaceError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_namespace_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_namespace(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameNamespaceError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_token_development_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceTokenDevelopmentOutput,
	crate::error::CreateGameNamespaceTokenDevelopmentError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled(generic))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameNamespaceTokenDevelopmentError {
			meta: generic,
			kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(
							crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled,
						)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::unauthorized_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::CreateGameNamespaceTokenDevelopmentError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_token_development_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceTokenDevelopmentOutput,
	crate::error::CreateGameNamespaceTokenDevelopmentError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_namespace_token_development_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_namespace_token_development(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_token_public_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceTokenPublicOutput,
	crate::error::CreateGameNamespaceTokenPublicError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameNamespaceTokenPublicError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameNamespaceTokenPublicError {
			meta: generic,
			kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameNamespaceTokenPublicError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_token_public_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceTokenPublicOutput,
	crate::error::CreateGameNamespaceTokenPublicError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_namespace_token_public_output::Builder::default();
		let _ = response;
		output =
			crate::json_deser::deser_operation_crate_operation_create_game_namespace_token_public(
				response.body().as_ref(),
				output,
			)
			.map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_version_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameVersionOutput, crate::error::CreateGameVersionError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameVersionError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameVersionError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameVersionError {
			meta: generic,
			kind: crate::error::CreateGameVersionErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameVersionError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameVersionError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_version_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameVersionOutput, crate::error::CreateGameVersionError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_version_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_version(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameVersionError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_matchmaker_lobby_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::DeleteMatchmakerLobbyOutput,
	crate::error::DeleteMatchmakerLobbyError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::DeleteMatchmakerLobbyError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::DeleteMatchmakerLobbyError {
			meta: generic,
			kind: crate::error::DeleteMatchmakerLobbyErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::DeleteMatchmakerLobbyError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_matchmaker_lobby_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::DeleteMatchmakerLobbyOutput,
	crate::error::DeleteMatchmakerLobbyError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::delete_matchmaker_lobby_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_delete_matchmaker_lobby(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_matchmaker_lobby_history_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ExportMatchmakerLobbyHistoryOutput,
	crate::error::ExportMatchmakerLobbyHistoryError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ExportMatchmakerLobbyHistoryError {
			meta: generic,
			kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ExportMatchmakerLobbyHistoryError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_matchmaker_lobby_history_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ExportMatchmakerLobbyHistoryOutput,
	crate::error::ExportMatchmakerLobbyHistoryError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::export_matchmaker_lobby_history_output::Builder::default();
		let _ = response;
		output =
			crate::json_deser::deser_operation_crate_operation_export_matchmaker_lobby_history(
				response.body().as_ref(),
				output,
			)
			.map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_by_id_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGameByIdOutput, crate::error::GetGameByIdError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameByIdError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameByIdError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameByIdError {
			meta: generic,
			kind: crate::error::GetGameByIdErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameByIdError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameByIdError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_by_id_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGameByIdOutput, crate::error::GetGameByIdError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_by_id_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_by_id(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameByIdError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_namespace_by_id_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameNamespaceByIdOutput,
	crate::error::GetGameNamespaceByIdError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameNamespaceByIdError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameNamespaceByIdError {
			meta: generic,
			kind: crate::error::GetGameNamespaceByIdErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameNamespaceByIdError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_namespace_by_id_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameNamespaceByIdOutput,
	crate::error::GetGameNamespaceByIdError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_namespace_by_id_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_namespace_by_id(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_games_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGamesOutput, crate::error::GetGamesError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGamesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGamesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGamesError {
			meta: generic,
			kind: crate::error::GetGamesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGamesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGamesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_games_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGamesOutput, crate::error::GetGamesError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_games_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_games(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGamesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_version_by_id_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameVersionByIdOutput,
	crate::error::GetGameVersionByIdError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameVersionByIdError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameVersionByIdError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameVersionByIdError {
			meta: generic,
			kind: crate::error::GetGameVersionByIdErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameVersionByIdError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameVersionByIdError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_version_by_id_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameVersionByIdOutput,
	crate::error::GetGameVersionByIdError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_version_by_id_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_version_by_id(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameVersionByIdError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_namespace_analytics_matchmaker_live_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetNamespaceAnalyticsMatchmakerLiveOutput,
	crate::error::GetNamespaceAnalyticsMatchmakerLiveError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled(generic))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
			meta: generic,
			kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(
							crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled,
						)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::unauthorized_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"NotFoundError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::GetNamespaceAnalyticsMatchmakerLiveError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_namespace_analytics_matchmaker_live_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetNamespaceAnalyticsMatchmakerLiveOutput,
	crate::error::GetNamespaceAnalyticsMatchmakerLiveError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_namespace_analytics_matchmaker_live_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_namespace_analytics_matchmaker_live(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_namespace_lobby_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetNamespaceLobbyOutput, crate::error::GetNamespaceLobbyError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetNamespaceLobbyError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetNamespaceLobbyError {
			meta: generic,
			kind: crate::error::GetNamespaceLobbyErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetNamespaceLobbyError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_namespace_lobby_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetNamespaceLobbyOutput, crate::error::GetNamespaceLobbyError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_namespace_lobby_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_namespace_lobby(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ray_perf_logs_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRayPerfLogsOutput, crate::error::GetRayPerfLogsError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetRayPerfLogsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetRayPerfLogsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetRayPerfLogsError {
			meta: generic,
			kind: crate::error::GetRayPerfLogsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetRayPerfLogsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetRayPerfLogsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ray_perf_logs_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRayPerfLogsOutput, crate::error::GetRayPerfLogsError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_ray_perf_logs_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_ray_perf_logs(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetRayPerfLogsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_region_tiers_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRegionTiersOutput, crate::error::GetRegionTiersError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetRegionTiersError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetRegionTiersError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetRegionTiersError {
			meta: generic,
			kind: crate::error::GetRegionTiersErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetRegionTiersError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetRegionTiersError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_region_tiers_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRegionTiersOutput, crate::error::GetRegionTiersError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_region_tiers_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_region_tiers(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetRegionTiersError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_team_billing_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTeamBillingOutput, crate::error::GetTeamBillingError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetTeamBillingError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetTeamBillingError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetTeamBillingError {
			meta: generic,
			kind: crate::error::GetTeamBillingErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetTeamBillingError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetTeamBillingError {
				meta: generic,
				kind: crate::error::GetTeamBillingErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetTeamBillingError {
				meta: generic,
				kind: crate::error::GetTeamBillingErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetTeamBillingError {
				meta: generic,
				kind: crate::error::GetTeamBillingErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetTeamBillingError {
				meta: generic,
				kind: crate::error::GetTeamBillingErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetTeamBillingError {
				meta: generic,
				kind: crate::error::GetTeamBillingErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetTeamBillingError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_team_billing_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTeamBillingOutput, crate::error::GetTeamBillingError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_team_billing_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_team_billing(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetTeamBillingError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_team_payments_list_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetTeamPaymentsListOutput,
	crate::error::GetTeamPaymentsListError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetTeamPaymentsListError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetTeamPaymentsListError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetTeamPaymentsListError {
			meta: generic,
			kind: crate::error::GetTeamPaymentsListErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetTeamPaymentsListError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetTeamPaymentsListError {
				meta: generic,
				kind: crate::error::GetTeamPaymentsListErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamPaymentsListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetTeamPaymentsListError {
				meta: generic,
				kind: crate::error::GetTeamPaymentsListErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamPaymentsListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetTeamPaymentsListError {
				meta: generic,
				kind: crate::error::GetTeamPaymentsListErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamPaymentsListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetTeamPaymentsListError {
				meta: generic,
				kind: crate::error::GetTeamPaymentsListErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamPaymentsListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetTeamPaymentsListError {
				meta: generic,
				kind: crate::error::GetTeamPaymentsListErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamPaymentsListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetTeamPaymentsListError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_team_payments_list_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetTeamPaymentsListOutput,
	crate::error::GetTeamPaymentsListError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_team_payments_list_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_team_payments_list(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetTeamPaymentsListError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_team_transfers_list_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetTeamTransfersListOutput,
	crate::error::GetTeamTransfersListError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetTeamTransfersListError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetTeamTransfersListError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetTeamTransfersListError {
			meta: generic,
			kind: crate::error::GetTeamTransfersListErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetTeamTransfersListError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetTeamTransfersListError {
				meta: generic,
				kind: crate::error::GetTeamTransfersListErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamTransfersListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetTeamTransfersListError {
				meta: generic,
				kind: crate::error::GetTeamTransfersListErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamTransfersListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetTeamTransfersListError {
				meta: generic,
				kind: crate::error::GetTeamTransfersListErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamTransfersListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetTeamTransfersListError {
				meta: generic,
				kind: crate::error::GetTeamTransfersListErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamTransfersListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetTeamTransfersListError {
				meta: generic,
				kind: crate::error::GetTeamTransfersListErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetTeamTransfersListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetTeamTransfersListError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_team_transfers_list_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetTeamTransfersListOutput,
	crate::error::GetTeamTransfersListError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_team_transfers_list_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_team_transfers_list(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetTeamTransfersListError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_inspect_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::InspectOutput, crate::error::InspectError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::InspectError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::InspectError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::InspectError {
			meta: generic,
			kind: crate::error::InspectErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::InspectError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::InspectError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_inspect_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::InspectOutput, crate::error::InspectError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::inspect_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_inspect(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::InspectError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_builds_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGameBuildsOutput, crate::error::ListGameBuildsError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListGameBuildsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListGameBuildsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListGameBuildsError {
			meta: generic,
			kind: crate::error::ListGameBuildsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListGameBuildsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListGameBuildsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_builds_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGameBuildsOutput, crate::error::ListGameBuildsError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_game_builds_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_game_builds(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListGameBuildsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_cdn_sites_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGameCdnSitesOutput, crate::error::ListGameCdnSitesError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListGameCdnSitesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListGameCdnSitesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListGameCdnSitesError {
			meta: generic,
			kind: crate::error::ListGameCdnSitesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListGameCdnSitesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListGameCdnSitesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_cdn_sites_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGameCdnSitesOutput, crate::error::ListGameCdnSitesError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_game_cdn_sites_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_game_cdn_sites(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListGameCdnSitesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_namespace_lobbies_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ListNamespaceLobbiesOutput,
	crate::error::ListNamespaceLobbiesError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListNamespaceLobbiesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListNamespaceLobbiesError {
			meta: generic,
			kind: crate::error::ListNamespaceLobbiesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListNamespaceLobbiesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_namespace_lobbies_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ListNamespaceLobbiesOutput,
	crate::error::ListNamespaceLobbiesError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_namespace_lobbies_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_namespace_lobbies(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_namespace_domain_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RemoveNamespaceDomainOutput,
	crate::error::RemoveNamespaceDomainError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::RemoveNamespaceDomainError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::RemoveNamespaceDomainError {
			meta: generic,
			kind: crate::error::RemoveNamespaceDomainErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::RemoveNamespaceDomainError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_namespace_domain_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RemoveNamespaceDomainOutput,
	crate::error::RemoveNamespaceDomainError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::remove_namespace_domain_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_team_billing_checkout_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::TeamBillingCheckoutOutput,
	crate::error::TeamBillingCheckoutError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::TeamBillingCheckoutError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::TeamBillingCheckoutError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::TeamBillingCheckoutError {
			meta: generic,
			kind: crate::error::TeamBillingCheckoutErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::TeamBillingCheckoutError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::TeamBillingCheckoutError {
				meta: generic,
				kind: crate::error::TeamBillingCheckoutErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::TeamBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::TeamBillingCheckoutError {
				meta: generic,
				kind: crate::error::TeamBillingCheckoutErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::TeamBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::TeamBillingCheckoutError {
				meta: generic,
				kind: crate::error::TeamBillingCheckoutErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::TeamBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::TeamBillingCheckoutError {
				meta: generic,
				kind: crate::error::TeamBillingCheckoutErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::TeamBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::TeamBillingCheckoutError {
				meta: generic,
				kind: crate::error::TeamBillingCheckoutErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::TeamBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::TeamBillingCheckoutError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_team_billing_checkout_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::TeamBillingCheckoutOutput,
	crate::error::TeamBillingCheckoutError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::team_billing_checkout_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_team_billing_checkout(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::TeamBillingCheckoutError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_toggle_namespace_domain_public_auth_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ToggleNamespaceDomainPublicAuthOutput,
	crate::error::ToggleNamespaceDomainPublicAuthError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ToggleNamespaceDomainPublicAuthError {
			meta: generic,
			kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ToggleNamespaceDomainPublicAuthError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_toggle_namespace_domain_public_auth_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ToggleNamespaceDomainPublicAuthOutput,
	crate::error::ToggleNamespaceDomainPublicAuthError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::toggle_namespace_domain_public_auth_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_namespace_matchmaker_config_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateGameNamespaceMatchmakerConfigOutput,
	crate::error::UpdateGameNamespaceMatchmakerConfigError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled(generic))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UpdateGameNamespaceMatchmakerConfigError {
			meta: generic,
			kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(
							crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled,
						)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::unauthorized_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"NotFoundError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::UpdateGameNamespaceMatchmakerConfigError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_namespace_matchmaker_config_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateGameNamespaceMatchmakerConfigOutput,
	crate::error::UpdateGameNamespaceMatchmakerConfigError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::update_game_namespace_matchmaker_config_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_namespace_version_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateGameNamespaceVersionOutput,
	crate::error::UpdateGameNamespaceVersionError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::UpdateGameNamespaceVersionError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UpdateGameNamespaceVersionError {
			meta: generic,
			kind: crate::error::UpdateGameNamespaceVersionErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::UpdateGameNamespaceVersionError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_namespace_version_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateGameNamespaceVersionOutput,
	crate::error::UpdateGameNamespaceVersionError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::update_game_namespace_version_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_namespace_domain_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateNamespaceDomainOutput,
	crate::error::UpdateNamespaceDomainError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UpdateNamespaceDomainError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::UpdateNamespaceDomainError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UpdateNamespaceDomainError {
			meta: generic,
			kind: crate::error::UpdateNamespaceDomainErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::UpdateNamespaceDomainError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UpdateNamespaceDomainError {
				meta: generic,
				kind: crate::error::UpdateNamespaceDomainErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UpdateNamespaceDomainError {
				meta: generic,
				kind: crate::error::UpdateNamespaceDomainErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UpdateNamespaceDomainError {
				meta: generic,
				kind: crate::error::UpdateNamespaceDomainErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::UpdateNamespaceDomainError {
				meta: generic,
				kind: crate::error::UpdateNamespaceDomainErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UpdateNamespaceDomainError {
				meta: generic,
				kind: crate::error::UpdateNamespaceDomainErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::UpdateNamespaceDomainError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_namespace_domain_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateNamespaceDomainOutput,
	crate::error::UpdateNamespaceDomainError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::update_namespace_domain_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateGameOutput, crate::error::ValidateGameError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ValidateGameError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateGameError {
			meta: generic,
			kind: crate::error::ValidateGameErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateGameError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateGameError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateGameOutput, crate::error::ValidateGameError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_game_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateGameError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceOutput,
	crate::error::ValidateGameNamespaceError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ValidateGameNamespaceError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateGameNamespaceError {
			meta: generic,
			kind: crate::error::ValidateGameNamespaceErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateGameNamespaceError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceOutput,
	crate::error::ValidateGameNamespaceError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_game_namespace_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game_namespace(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_matchmaker_config_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceMatchmakerConfigOutput,
	crate::error::ValidateGameNamespaceMatchmakerConfigError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(
				crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled(generic),
			)
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::internal_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_internal_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"RateLimitError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::rate_limit_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::forbidden_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"UnauthorizedError" => crate::error::ValidateGameNamespaceMatchmakerConfigError {
			meta: generic,
			kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(
				{
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				},
			),
		},
		"NotFoundError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::not_found_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::ValidateGameNamespaceMatchmakerConfigError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_matchmaker_config_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceMatchmakerConfigOutput,
	crate::error::ValidateGameNamespaceMatchmakerConfigError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output =
			crate::output::validate_game_namespace_matchmaker_config_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game_namespace_matchmaker_config(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_token_development_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceTokenDevelopmentOutput,
	crate::error::ValidateGameNamespaceTokenDevelopmentError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(
				crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled(generic),
			)
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::internal_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_internal_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"RateLimitError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::rate_limit_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::forbidden_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"UnauthorizedError" => crate::error::ValidateGameNamespaceTokenDevelopmentError {
			meta: generic,
			kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(
				{
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				},
			),
		},
		"NotFoundError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::not_found_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::ValidateGameNamespaceTokenDevelopmentError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_token_development_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceTokenDevelopmentOutput,
	crate::error::ValidateGameNamespaceTokenDevelopmentError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output =
			crate::output::validate_game_namespace_token_development_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game_namespace_token_development(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_version_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameVersionOutput,
	crate::error::ValidateGameVersionError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameVersionError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ValidateGameVersionError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateGameVersionError {
			meta: generic,
			kind: crate::error::ValidateGameVersionErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateGameVersionError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateGameVersionError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_version_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameVersionOutput,
	crate::error::ValidateGameVersionError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_game_version_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game_version(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateGameVersionError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_team_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateTeamOutput, crate::error::ValidateTeamError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateTeamError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ValidateTeamError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateTeamError {
			meta: generic,
			kind: crate::error::ValidateTeamErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateTeamError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateTeamError {
				meta: generic,
				kind: crate::error::ValidateTeamErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateTeamError {
				meta: generic,
				kind: crate::error::ValidateTeamErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateTeamError {
				meta: generic,
				kind: crate::error::ValidateTeamErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateTeamError {
				meta: generic,
				kind: crate::error::ValidateTeamErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateTeamError {
				meta: generic,
				kind: crate::error::ValidateTeamErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateTeamError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateTeamError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_team_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateTeamOutput, crate::error::ValidateTeamError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_team_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_team(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateTeamError::unhandled)?;
		output.build()
	})
}
