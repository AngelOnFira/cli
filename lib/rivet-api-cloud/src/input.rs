// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CompleteUploadInput`](crate::input::CompleteUploadInput)
pub mod complete_upload_input {
	/// A builder for [`CompleteUploadInput`](crate::input::CompleteUploadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) upload_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.upload_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.upload_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CompleteUploadInput`](crate::input::CompleteUploadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CompleteUploadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CompleteUploadInput {
				upload_id: self.upload_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CompleteUploadInputOperationOutputAlias = crate::operation::CompleteUpload;
#[doc(hidden)]
pub type CompleteUploadInputOperationRetryAlias = ();
impl CompleteUploadInput {
	/// Consumes the builder and constructs an Operation<[`CompleteUpload`](crate::operation::CompleteUpload)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CompleteUpload, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CompleteUploadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_1 = &_input.upload_id;
				let input_1 = input_1.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					},
				)?;
				let upload_id = aws_smithy_http::label::fmt_string(input_1, false);
				if upload_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/uploads/{upload_id}/complete",
					upload_id = upload_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CompleteUploadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CompleteUpload::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CompleteUpload",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CompleteUploadInput`](crate::input::CompleteUploadInput)
	pub fn builder() -> crate::input::complete_upload_input::Builder {
		crate::input::complete_upload_input::Builder::default()
	}
}

/// See [`ConvertTeamInput`](crate::input::ConvertTeamInput)
pub mod convert_team_input {
	/// A builder for [`ConvertTeamInput`](crate::input::ConvertTeamInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) team_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.team_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.team_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ConvertTeamInput`](crate::input::ConvertTeamInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ConvertTeamInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ConvertTeamInput {
				team_id: self.team_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ConvertTeamInputOperationOutputAlias = crate::operation::ConvertTeam;
#[doc(hidden)]
pub type ConvertTeamInputOperationRetryAlias = ();
impl ConvertTeamInput {
	/// Consumes the builder and constructs an Operation<[`ConvertTeam`](crate::operation::ConvertTeam)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ConvertTeam, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ConvertTeamInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_2 = &_input.team_id;
				let input_2 = input_2.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					},
				)?;
				let team_id = aws_smithy_http::label::fmt_string(input_2, false);
				if team_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/teams/{team_id}/convert", team_id = team_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ConvertTeamInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ConvertTeam::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ConvertTeam",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ConvertTeamInput`](crate::input::ConvertTeamInput)
	pub fn builder() -> crate::input::convert_team_input::Builder {
		crate::input::convert_team_input::Builder::default()
	}
}

/// See [`CreateCloudTokenInput`](crate::input::CreateCloudTokenInput)
pub mod create_cloud_token_input {
	/// A builder for [`CreateCloudTokenInput`](crate::input::CreateCloudTokenInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateCloudTokenInput`](crate::input::CreateCloudTokenInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateCloudTokenInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateCloudTokenInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateCloudTokenInputOperationOutputAlias = crate::operation::CreateCloudToken;
#[doc(hidden)]
pub type CreateCloudTokenInputOperationRetryAlias = ();
impl CreateCloudTokenInput {
	/// Consumes the builder and constructs an Operation<[`CreateCloudToken`](crate::operation::CreateCloudToken)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateCloudToken, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateCloudTokenInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_3 = &_input.game_id;
				let input_3 = input_3.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_3, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/tokens/cloud", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateCloudTokenInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateCloudToken::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateCloudToken",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateCloudTokenInput`](crate::input::CreateCloudTokenInput)
	pub fn builder() -> crate::input::create_cloud_token_input::Builder {
		crate::input::create_cloud_token_input::Builder::default()
	}
}

/// See [`CreateGameInput`](crate::input::CreateGameInput)
pub mod create_game_input {
	/// A builder for [`CreateGameInput`](crate::input::CreateGameInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) name_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) developer_team_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn developer_team_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.developer_team_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_developer_team_id(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.developer_team_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameInput`](crate::input::CreateGameInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameInput {
				name_id: self.name_id,
				display_name: self.display_name,
				developer_team_id: self.developer_team_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameInputOperationOutputAlias = crate::operation::CreateGame;
#[doc(hidden)]
pub type CreateGameInputOperationRetryAlias = ();
impl CreateGameInput {
	/// Consumes the builder and constructs an Operation<[`CreateGame`](crate::operation::CreateGame)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGame, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/games").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGame::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGame",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameInput`](crate::input::CreateGameInput)
	pub fn builder() -> crate::input::create_game_input::Builder {
		crate::input::create_game_input::Builder::default()
	}
}

/// See [`CreateGameBuildInput`](crate::input::CreateGameBuildInput)
pub mod create_game_build_input {
	/// A builder for [`CreateGameBuildInput`](crate::input::CreateGameBuildInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) image_tag: std::option::Option<std::string::String>,
		pub(crate) image_file: std::option::Option<crate::model::UploadPrepareFile>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn image_tag(mut self, input: impl Into<std::string::String>) -> Self {
			self.image_tag = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_image_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.image_tag = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn image_file(mut self, input: crate::model::UploadPrepareFile) -> Self {
			self.image_file = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_image_file(
			mut self,
			input: std::option::Option<crate::model::UploadPrepareFile>,
		) -> Self {
			self.image_file = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameBuildInput`](crate::input::CreateGameBuildInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameBuildInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameBuildInput {
				game_id: self.game_id,
				display_name: self.display_name,
				image_tag: self.image_tag,
				image_file: self.image_file,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameBuildInputOperationOutputAlias = crate::operation::CreateGameBuild;
#[doc(hidden)]
pub type CreateGameBuildInputOperationRetryAlias = ();
impl CreateGameBuildInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameBuild`](crate::operation::CreateGameBuild)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameBuild, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameBuildInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_4 = &_input.game_id;
				let input_4 = input_4.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_4, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/builds", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameBuildInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game_build(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameBuild::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameBuild",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameBuildInput`](crate::input::CreateGameBuildInput)
	pub fn builder() -> crate::input::create_game_build_input::Builder {
		crate::input::create_game_build_input::Builder::default()
	}
}

/// See [`CreateGameCdnSiteInput`](crate::input::CreateGameCdnSiteInput)
pub mod create_game_cdn_site_input {
	/// A builder for [`CreateGameCdnSiteInput`](crate::input::CreateGameCdnSiteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) files: std::option::Option<std::vec::Vec<crate::model::UploadPrepareFile>>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Appends an item to `files`.
		///
		/// To override the contents of this collection use [`set_files`](Self::set_files).
		///
		pub fn files(mut self, input: crate::model::UploadPrepareFile) -> Self {
			let mut v = self.files.unwrap_or_default();
			v.push(input);
			self.files = Some(v);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_files(
			mut self,
			input: std::option::Option<std::vec::Vec<crate::model::UploadPrepareFile>>,
		) -> Self {
			self.files = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameCdnSiteInput`](crate::input::CreateGameCdnSiteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameCdnSiteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameCdnSiteInput {
				game_id: self.game_id,
				display_name: self.display_name,
				files: self.files,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameCdnSiteInputOperationOutputAlias = crate::operation::CreateGameCdnSite;
#[doc(hidden)]
pub type CreateGameCdnSiteInputOperationRetryAlias = ();
impl CreateGameCdnSiteInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameCdnSite`](crate::operation::CreateGameCdnSite)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameCdnSite, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameCdnSiteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_5 = &_input.game_id;
				let input_5 = input_5.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_5, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/cdn/sites", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameCdnSiteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game_cdn_site(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameCdnSite::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameCdnSite",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameCdnSiteInput`](crate::input::CreateGameCdnSiteInput)
	pub fn builder() -> crate::input::create_game_cdn_site_input::Builder {
		crate::input::create_game_cdn_site_input::Builder::default()
	}
}

/// See [`CreateGameNamespaceInput`](crate::input::CreateGameNamespaceInput)
pub mod create_game_namespace_input {
	/// A builder for [`CreateGameNamespaceInput`](crate::input::CreateGameNamespaceInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) version_id: std::option::Option<std::string::String>,
		pub(crate) name_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.version_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.version_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameNamespaceInput`](crate::input::CreateGameNamespaceInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameNamespaceInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameNamespaceInput {
				game_id: self.game_id,
				display_name: self.display_name,
				version_id: self.version_id,
				name_id: self.name_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameNamespaceInputOperationOutputAlias = crate::operation::CreateGameNamespace;
#[doc(hidden)]
pub type CreateGameNamespaceInputOperationRetryAlias = ();
impl CreateGameNamespaceInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameNamespace`](crate::operation::CreateGameNamespace)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameNamespace, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameNamespaceInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_6 = &_input.game_id;
				let input_6 = input_6.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_6, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/namespaces", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameNamespaceInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game_namespace(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameNamespace::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameNamespace",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameNamespaceInput`](crate::input::CreateGameNamespaceInput)
	pub fn builder() -> crate::input::create_game_namespace_input::Builder {
		crate::input::create_game_namespace_input::Builder::default()
	}
}

/// See [`CreateGameNamespaceTokenDevelopmentInput`](crate::input::CreateGameNamespaceTokenDevelopmentInput)
pub mod create_game_namespace_token_development_input {
	/// A builder for [`CreateGameNamespaceTokenDevelopmentInput`](crate::input::CreateGameNamespaceTokenDevelopmentInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) hostname: std::option::Option<std::string::String>,
		pub(crate) lobby_ports:
			std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
			self.hostname = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.hostname = input;
			self
		}
		/// Appends an item to `lobby_ports`.
		///
		/// To override the contents of this collection use [`set_lobby_ports`](Self::set_lobby_ports).
		///
		pub fn lobby_ports(mut self, input: crate::model::LobbyGroupRuntimeDockerPort) -> Self {
			let mut v = self.lobby_ports.unwrap_or_default();
			v.push(input);
			self.lobby_ports = Some(v);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_lobby_ports(
			mut self,
			input: std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
		) -> Self {
			self.lobby_ports = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameNamespaceTokenDevelopmentInput`](crate::input::CreateGameNamespaceTokenDevelopmentInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameNamespaceTokenDevelopmentInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameNamespaceTokenDevelopmentInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				hostname: self.hostname,
				lobby_ports: self.lobby_ports,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameNamespaceTokenDevelopmentInputOperationOutputAlias =
	crate::operation::CreateGameNamespaceTokenDevelopment;
#[doc(hidden)]
pub type CreateGameNamespaceTokenDevelopmentInputOperationRetryAlias = ();
impl CreateGameNamespaceTokenDevelopmentInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameNamespaceTokenDevelopment`](crate::operation::CreateGameNamespaceTokenDevelopment)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::CreateGameNamespaceTokenDevelopment,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameNamespaceTokenDevelopmentInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_7 = &_input.game_id;
				let input_7 = input_7.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_7, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_8 = &_input.namespace_id;
				let input_8 = input_8.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_8, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/tokens/development",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameNamespaceTokenDevelopmentInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_game_namespace_token_development(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameNamespaceTokenDevelopment::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameNamespaceTokenDevelopment",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameNamespaceTokenDevelopmentInput`](crate::input::CreateGameNamespaceTokenDevelopmentInput)
	pub fn builder() -> crate::input::create_game_namespace_token_development_input::Builder {
		crate::input::create_game_namespace_token_development_input::Builder::default()
	}
}

/// See [`CreateGameNamespaceTokenPublicInput`](crate::input::CreateGameNamespaceTokenPublicInput)
pub mod create_game_namespace_token_public_input {
	/// A builder for [`CreateGameNamespaceTokenPublicInput`](crate::input::CreateGameNamespaceTokenPublicInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameNamespaceTokenPublicInput`](crate::input::CreateGameNamespaceTokenPublicInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameNamespaceTokenPublicInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameNamespaceTokenPublicInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameNamespaceTokenPublicInputOperationOutputAlias =
	crate::operation::CreateGameNamespaceTokenPublic;
#[doc(hidden)]
pub type CreateGameNamespaceTokenPublicInputOperationRetryAlias = ();
impl CreateGameNamespaceTokenPublicInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameNamespaceTokenPublic`](crate::operation::CreateGameNamespaceTokenPublic)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameNamespaceTokenPublic, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameNamespaceTokenPublicInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_9 = &_input.game_id;
				let input_9 = input_9.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_9, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_10 = &_input.namespace_id;
				let input_10 = input_10.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_10, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/tokens/public",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameNamespaceTokenPublicInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameNamespaceTokenPublic::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameNamespaceTokenPublic",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameNamespaceTokenPublicInput`](crate::input::CreateGameNamespaceTokenPublicInput)
	pub fn builder() -> crate::input::create_game_namespace_token_public_input::Builder {
		crate::input::create_game_namespace_token_public_input::Builder::default()
	}
}

/// See [`CreateGameVersionInput`](crate::input::CreateGameVersionInput)
pub mod create_game_version_input {
	/// A builder for [`CreateGameVersionInput`](crate::input::CreateGameVersionInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) config: std::option::Option<crate::model::CloudVersionConfig>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn config(mut self, input: crate::model::CloudVersionConfig) -> Self {
			self.config = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_config(
			mut self,
			input: std::option::Option<crate::model::CloudVersionConfig>,
		) -> Self {
			self.config = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameVersionInput`](crate::input::CreateGameVersionInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameVersionInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameVersionInput {
				game_id: self.game_id,
				display_name: self.display_name,
				config: self.config,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameVersionInputOperationOutputAlias = crate::operation::CreateGameVersion;
#[doc(hidden)]
pub type CreateGameVersionInputOperationRetryAlias = ();
impl CreateGameVersionInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameVersion`](crate::operation::CreateGameVersion)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameVersion, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameVersionInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_11 = &_input.game_id;
				let input_11 = input_11.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_11, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/versions", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameVersionInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game_version(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameVersion::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameVersion",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameVersionInput`](crate::input::CreateGameVersionInput)
	pub fn builder() -> crate::input::create_game_version_input::Builder {
		crate::input::create_game_version_input::Builder::default()
	}
}

/// See [`DeleteMatchmakerLobbyInput`](crate::input::DeleteMatchmakerLobbyInput)
pub mod delete_matchmaker_lobby_input {
	/// A builder for [`DeleteMatchmakerLobbyInput`](crate::input::DeleteMatchmakerLobbyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) lobby_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		/// Consumes the builder and constructs a [`DeleteMatchmakerLobbyInput`](crate::input::DeleteMatchmakerLobbyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::DeleteMatchmakerLobbyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::DeleteMatchmakerLobbyInput {
				game_id: self.game_id,
				lobby_id: self.lobby_id,
			})
		}
	}
}
#[doc(hidden)]
pub type DeleteMatchmakerLobbyInputOperationOutputAlias = crate::operation::DeleteMatchmakerLobby;
#[doc(hidden)]
pub type DeleteMatchmakerLobbyInputOperationRetryAlias = ();
impl DeleteMatchmakerLobbyInput {
	/// Consumes the builder and constructs an Operation<[`DeleteMatchmakerLobby`](crate::operation::DeleteMatchmakerLobby)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::DeleteMatchmakerLobby, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::DeleteMatchmakerLobbyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_12 = &_input.game_id;
				let input_12 = input_12.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_12, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_13 = &_input.lobby_id;
				let input_13 = input_13.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					},
				)?;
				let lobby_id = aws_smithy_http::label::fmt_string(input_13, false);
				if lobby_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/matchmaker/lobbies/{lobby_id}",
					game_id = game_id,
					lobby_id = lobby_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::DeleteMatchmakerLobbyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::DeleteMatchmakerLobby::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"DeleteMatchmakerLobby",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`DeleteMatchmakerLobbyInput`](crate::input::DeleteMatchmakerLobbyInput)
	pub fn builder() -> crate::input::delete_matchmaker_lobby_input::Builder {
		crate::input::delete_matchmaker_lobby_input::Builder::default()
	}
}

/// See [`ExportMatchmakerLobbyHistoryInput`](crate::input::ExportMatchmakerLobbyHistoryInput)
pub mod export_matchmaker_lobby_history_input {
	/// A builder for [`ExportMatchmakerLobbyHistoryInput`](crate::input::ExportMatchmakerLobbyHistoryInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) query_start: std::option::Option<i64>,
		pub(crate) query_end: std::option::Option<i64>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn query_start(mut self, input: i64) -> Self {
			self.query_start = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_query_start(mut self, input: std::option::Option<i64>) -> Self {
			self.query_start = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn query_end(mut self, input: i64) -> Self {
			self.query_end = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_query_end(mut self, input: std::option::Option<i64>) -> Self {
			self.query_end = input;
			self
		}
		/// Consumes the builder and constructs a [`ExportMatchmakerLobbyHistoryInput`](crate::input::ExportMatchmakerLobbyHistoryInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ExportMatchmakerLobbyHistoryInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ExportMatchmakerLobbyHistoryInput {
				game_id: self.game_id,
				query_start: self.query_start,
				query_end: self.query_end,
			})
		}
	}
}
#[doc(hidden)]
pub type ExportMatchmakerLobbyHistoryInputOperationOutputAlias =
	crate::operation::ExportMatchmakerLobbyHistory;
#[doc(hidden)]
pub type ExportMatchmakerLobbyHistoryInputOperationRetryAlias = ();
impl ExportMatchmakerLobbyHistoryInput {
	/// Consumes the builder and constructs an Operation<[`ExportMatchmakerLobbyHistory`](crate::operation::ExportMatchmakerLobbyHistory)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ExportMatchmakerLobbyHistory, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ExportMatchmakerLobbyHistoryInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_14 = &_input.game_id;
				let input_14 = input_14.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_14, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/matchmaker/lobbies/export-history",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ExportMatchmakerLobbyHistoryInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_export_matchmaker_lobby_history(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ExportMatchmakerLobbyHistory::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ExportMatchmakerLobbyHistory",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ExportMatchmakerLobbyHistoryInput`](crate::input::ExportMatchmakerLobbyHistoryInput)
	pub fn builder() -> crate::input::export_matchmaker_lobby_history_input::Builder {
		crate::input::export_matchmaker_lobby_history_input::Builder::default()
	}
}

/// See [`GetGameByIdInput`](crate::input::GetGameByIdInput)
pub mod get_game_by_id_input {
	/// A builder for [`GetGameByIdInput`](crate::input::GetGameByIdInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameByIdInput`](crate::input::GetGameByIdInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameByIdInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameByIdInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameByIdInputOperationOutputAlias = crate::operation::GetGameById;
#[doc(hidden)]
pub type GetGameByIdInputOperationRetryAlias = ();
impl GetGameByIdInput {
	/// Consumes the builder and constructs an Operation<[`GetGameById`](crate::operation::GetGameById)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameById, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameByIdInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_15 = &_input.game_id;
				let input_15 = input_15.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_15, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameByIdInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameById::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameById",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameByIdInput`](crate::input::GetGameByIdInput)
	pub fn builder() -> crate::input::get_game_by_id_input::Builder {
		crate::input::get_game_by_id_input::Builder::default()
	}
}

/// See [`GetGameNamespaceByIdInput`](crate::input::GetGameNamespaceByIdInput)
pub mod get_game_namespace_by_id_input {
	/// A builder for [`GetGameNamespaceByIdInput`](crate::input::GetGameNamespaceByIdInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameNamespaceByIdInput`](crate::input::GetGameNamespaceByIdInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameNamespaceByIdInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameNamespaceByIdInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameNamespaceByIdInputOperationOutputAlias = crate::operation::GetGameNamespaceById;
#[doc(hidden)]
pub type GetGameNamespaceByIdInputOperationRetryAlias = ();
impl GetGameNamespaceByIdInput {
	/// Consumes the builder and constructs an Operation<[`GetGameNamespaceById`](crate::operation::GetGameNamespaceById)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameNamespaceById, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameNamespaceByIdInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_16 = &_input.game_id;
				let input_16 = input_16.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_16, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_17 = &_input.namespace_id;
				let input_17 = input_17.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_17, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameNamespaceByIdInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameNamespaceById::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameNamespaceById",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameNamespaceByIdInput`](crate::input::GetGameNamespaceByIdInput)
	pub fn builder() -> crate::input::get_game_namespace_by_id_input::Builder {
		crate::input::get_game_namespace_by_id_input::Builder::default()
	}
}

/// See [`GetGamesInput`](crate::input::GetGamesInput)
pub mod get_games_input {
	/// A builder for [`GetGamesInput`](crate::input::GetGamesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`GetGamesInput`](crate::input::GetGamesInput)
		pub fn build(
			self,
		) -> std::result::Result<crate::input::GetGamesInput, aws_smithy_http::operation::BuildError>
		{
			Ok(crate::input::GetGamesInput {})
		}
	}
}
#[doc(hidden)]
pub type GetGamesInputOperationOutputAlias = crate::operation::GetGames;
#[doc(hidden)]
pub type GetGamesInputOperationRetryAlias = ();
impl GetGamesInput {
	/// Consumes the builder and constructs an Operation<[`GetGames`](crate::operation::GetGames)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGames, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGamesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/games").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGamesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op =
			aws_smithy_http::operation::Operation::new(request, crate::operation::GetGames::new())
				.with_metadata(aws_smithy_http::operation::Metadata::new(
					"GetGames",
					"CloudService",
				));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGamesInput`](crate::input::GetGamesInput)
	pub fn builder() -> crate::input::get_games_input::Builder {
		crate::input::get_games_input::Builder::default()
	}
}

/// See [`GetGameVersionByIdInput`](crate::input::GetGameVersionByIdInput)
pub mod get_game_version_by_id_input {
	/// A builder for [`GetGameVersionByIdInput`](crate::input::GetGameVersionByIdInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) version_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.version_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.version_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameVersionByIdInput`](crate::input::GetGameVersionByIdInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameVersionByIdInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameVersionByIdInput {
				game_id: self.game_id,
				version_id: self.version_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameVersionByIdInputOperationOutputAlias = crate::operation::GetGameVersionById;
#[doc(hidden)]
pub type GetGameVersionByIdInputOperationRetryAlias = ();
impl GetGameVersionByIdInput {
	/// Consumes the builder and constructs an Operation<[`GetGameVersionById`](crate::operation::GetGameVersionById)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameVersionById, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameVersionByIdInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_18 = &_input.game_id;
				let input_18 = input_18.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_18, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_19 = &_input.version_id;
				let input_19 = input_19.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "version_id",
						details: "cannot be empty or unset",
					},
				)?;
				let version_id = aws_smithy_http::label::fmt_string(input_19, false);
				if version_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "version_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/versions/{version_id}",
					game_id = game_id,
					version_id = version_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameVersionByIdInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameVersionById::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameVersionById",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameVersionByIdInput`](crate::input::GetGameVersionByIdInput)
	pub fn builder() -> crate::input::get_game_version_by_id_input::Builder {
		crate::input::get_game_version_by_id_input::Builder::default()
	}
}

/// See [`GetNamespaceAnalyticsMatchmakerLiveInput`](crate::input::GetNamespaceAnalyticsMatchmakerLiveInput)
pub mod get_namespace_analytics_matchmaker_live_input {
	/// A builder for [`GetNamespaceAnalyticsMatchmakerLiveInput`](crate::input::GetNamespaceAnalyticsMatchmakerLiveInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetNamespaceAnalyticsMatchmakerLiveInput`](crate::input::GetNamespaceAnalyticsMatchmakerLiveInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetNamespaceAnalyticsMatchmakerLiveInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetNamespaceAnalyticsMatchmakerLiveInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetNamespaceAnalyticsMatchmakerLiveInputOperationOutputAlias =
	crate::operation::GetNamespaceAnalyticsMatchmakerLive;
#[doc(hidden)]
pub type GetNamespaceAnalyticsMatchmakerLiveInputOperationRetryAlias = ();
impl GetNamespaceAnalyticsMatchmakerLiveInput {
	/// Consumes the builder and constructs an Operation<[`GetNamespaceAnalyticsMatchmakerLive`](crate::operation::GetNamespaceAnalyticsMatchmakerLive)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::GetNamespaceAnalyticsMatchmakerLive,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetNamespaceAnalyticsMatchmakerLiveInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_20 = &_input.game_id;
				let input_20 = input_20.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_20, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_21 = &_input.namespace_id;
				let input_21 = input_21.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_21, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/analytics/matchmaker/live",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetNamespaceAnalyticsMatchmakerLiveInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetNamespaceAnalyticsMatchmakerLive::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetNamespaceAnalyticsMatchmakerLive",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetNamespaceAnalyticsMatchmakerLiveInput`](crate::input::GetNamespaceAnalyticsMatchmakerLiveInput)
	pub fn builder() -> crate::input::get_namespace_analytics_matchmaker_live_input::Builder {
		crate::input::get_namespace_analytics_matchmaker_live_input::Builder::default()
	}
}

/// See [`GetNamespaceLobbyInput`](crate::input::GetNamespaceLobbyInput)
pub mod get_namespace_lobby_input {
	/// A builder for [`GetNamespaceLobbyInput`](crate::input::GetNamespaceLobbyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) lobby_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetNamespaceLobbyInput`](crate::input::GetNamespaceLobbyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetNamespaceLobbyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetNamespaceLobbyInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				lobby_id: self.lobby_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetNamespaceLobbyInputOperationOutputAlias = crate::operation::GetNamespaceLobby;
#[doc(hidden)]
pub type GetNamespaceLobbyInputOperationRetryAlias = ();
impl GetNamespaceLobbyInput {
	/// Consumes the builder and constructs an Operation<[`GetNamespaceLobby`](crate::operation::GetNamespaceLobby)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetNamespaceLobby, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetNamespaceLobbyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_22 = &_input.game_id;
				let input_22 = input_22.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_22, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_23 = &_input.namespace_id;
				let input_23 = input_23.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_23, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				let input_24 = &_input.lobby_id;
				let input_24 = input_24.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					},
				)?;
				let lobby_id = aws_smithy_http::label::fmt_string(input_24, false);
				if lobby_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/logs/lobbies/{lobby_id}",
					game_id = game_id,
					namespace_id = namespace_id,
					lobby_id = lobby_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetNamespaceLobbyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetNamespaceLobby::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetNamespaceLobby",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetNamespaceLobbyInput`](crate::input::GetNamespaceLobbyInput)
	pub fn builder() -> crate::input::get_namespace_lobby_input::Builder {
		crate::input::get_namespace_lobby_input::Builder::default()
	}
}

/// See [`GetRayPerfLogsInput`](crate::input::GetRayPerfLogsInput)
pub mod get_ray_perf_logs_input {
	/// A builder for [`GetRayPerfLogsInput`](crate::input::GetRayPerfLogsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) ray_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn ray_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.ray_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_ray_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.ray_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetRayPerfLogsInput`](crate::input::GetRayPerfLogsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetRayPerfLogsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetRayPerfLogsInput {
				ray_id: self.ray_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetRayPerfLogsInputOperationOutputAlias = crate::operation::GetRayPerfLogs;
#[doc(hidden)]
pub type GetRayPerfLogsInputOperationRetryAlias = ();
impl GetRayPerfLogsInput {
	/// Consumes the builder and constructs an Operation<[`GetRayPerfLogs`](crate::operation::GetRayPerfLogs)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetRayPerfLogs, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetRayPerfLogsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_25 = &_input.ray_id;
				let input_25 = input_25.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "ray_id",
						details: "cannot be empty or unset",
					},
				)?;
				let ray_id = aws_smithy_http::label::fmt_string(input_25, false);
				if ray_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "ray_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/rays/{ray_id}/perf", ray_id = ray_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetRayPerfLogsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetRayPerfLogs::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetRayPerfLogs",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetRayPerfLogsInput`](crate::input::GetRayPerfLogsInput)
	pub fn builder() -> crate::input::get_ray_perf_logs_input::Builder {
		crate::input::get_ray_perf_logs_input::Builder::default()
	}
}

/// See [`GetRegionTiersInput`](crate::input::GetRegionTiersInput)
pub mod get_region_tiers_input {
	/// A builder for [`GetRegionTiersInput`](crate::input::GetRegionTiersInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`GetRegionTiersInput`](crate::input::GetRegionTiersInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetRegionTiersInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetRegionTiersInput {})
		}
	}
}
#[doc(hidden)]
pub type GetRegionTiersInputOperationOutputAlias = crate::operation::GetRegionTiers;
#[doc(hidden)]
pub type GetRegionTiersInputOperationRetryAlias = ();
impl GetRegionTiersInput {
	/// Consumes the builder and constructs an Operation<[`GetRegionTiers`](crate::operation::GetRegionTiers)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetRegionTiers, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetRegionTiersInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/region-tiers").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetRegionTiersInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetRegionTiers::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetRegionTiers",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetRegionTiersInput`](crate::input::GetRegionTiersInput)
	pub fn builder() -> crate::input::get_region_tiers_input::Builder {
		crate::input::get_region_tiers_input::Builder::default()
	}
}

/// See [`GetTeamBillingInput`](crate::input::GetTeamBillingInput)
pub mod get_team_billing_input {
	/// A builder for [`GetTeamBillingInput`](crate::input::GetTeamBillingInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) team_id: std::option::Option<std::string::String>,
		pub(crate) query_start: std::option::Option<i64>,
		pub(crate) query_end: std::option::Option<i64>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.team_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.team_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn query_start(mut self, input: i64) -> Self {
			self.query_start = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_query_start(mut self, input: std::option::Option<i64>) -> Self {
			self.query_start = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn query_end(mut self, input: i64) -> Self {
			self.query_end = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_query_end(mut self, input: std::option::Option<i64>) -> Self {
			self.query_end = input;
			self
		}
		/// Consumes the builder and constructs a [`GetTeamBillingInput`](crate::input::GetTeamBillingInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetTeamBillingInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetTeamBillingInput {
				team_id: self.team_id,
				query_start: self.query_start,
				query_end: self.query_end,
			})
		}
	}
}
#[doc(hidden)]
pub type GetTeamBillingInputOperationOutputAlias = crate::operation::GetTeamBilling;
#[doc(hidden)]
pub type GetTeamBillingInputOperationRetryAlias = ();
impl GetTeamBillingInput {
	/// Consumes the builder and constructs an Operation<[`GetTeamBilling`](crate::operation::GetTeamBilling)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetTeamBilling, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetTeamBillingInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_26 = &_input.team_id;
				let input_26 = input_26.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					},
				)?;
				let team_id = aws_smithy_http::label::fmt_string(input_26, false);
				if team_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/teams/{team_id}/billing", team_id = team_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetTeamBillingInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_27) = &_input.query_start {
					query.push_kv(
						"query_start",
						aws_smithy_types::primitive::Encoder::from(*inner_27).encode(),
					);
				}
				if let Some(inner_28) = &_input.query_end {
					query.push_kv(
						"query_end",
						aws_smithy_types::primitive::Encoder::from(*inner_28).encode(),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetTeamBillingInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetTeamBilling::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetTeamBilling",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetTeamBillingInput`](crate::input::GetTeamBillingInput)
	pub fn builder() -> crate::input::get_team_billing_input::Builder {
		crate::input::get_team_billing_input::Builder::default()
	}
}

/// See [`GetTeamPaymentsListInput`](crate::input::GetTeamPaymentsListInput)
pub mod get_team_payments_list_input {
	/// A builder for [`GetTeamPaymentsListInput`](crate::input::GetTeamPaymentsListInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) team_id: std::option::Option<std::string::String>,
		pub(crate) start_payment_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.team_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.team_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn start_payment_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.start_payment_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_start_payment_id(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.start_payment_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetTeamPaymentsListInput`](crate::input::GetTeamPaymentsListInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetTeamPaymentsListInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetTeamPaymentsListInput {
				team_id: self.team_id,
				start_payment_id: self.start_payment_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetTeamPaymentsListInputOperationOutputAlias = crate::operation::GetTeamPaymentsList;
#[doc(hidden)]
pub type GetTeamPaymentsListInputOperationRetryAlias = ();
impl GetTeamPaymentsListInput {
	/// Consumes the builder and constructs an Operation<[`GetTeamPaymentsList`](crate::operation::GetTeamPaymentsList)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetTeamPaymentsList, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetTeamPaymentsListInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_29 = &_input.team_id;
				let input_29 = input_29.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					},
				)?;
				let team_id = aws_smithy_http::label::fmt_string(input_29, false);
				if team_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/teams/{team_id}/billing/payments",
					team_id = team_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetTeamPaymentsListInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_30) = &_input.start_payment_id {
					query.push_kv(
						"start_payment_id",
						&aws_smithy_http::query::fmt_string(&inner_30),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetTeamPaymentsListInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetTeamPaymentsList::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetTeamPaymentsList",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetTeamPaymentsListInput`](crate::input::GetTeamPaymentsListInput)
	pub fn builder() -> crate::input::get_team_payments_list_input::Builder {
		crate::input::get_team_payments_list_input::Builder::default()
	}
}

/// See [`GetTeamTransfersListInput`](crate::input::GetTeamTransfersListInput)
pub mod get_team_transfers_list_input {
	/// A builder for [`GetTeamTransfersListInput`](crate::input::GetTeamTransfersListInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) team_id: std::option::Option<std::string::String>,
		pub(crate) start_transfer_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.team_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.team_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn start_transfer_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.start_transfer_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_start_transfer_id(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.start_transfer_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetTeamTransfersListInput`](crate::input::GetTeamTransfersListInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetTeamTransfersListInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetTeamTransfersListInput {
				team_id: self.team_id,
				start_transfer_id: self.start_transfer_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetTeamTransfersListInputOperationOutputAlias = crate::operation::GetTeamTransfersList;
#[doc(hidden)]
pub type GetTeamTransfersListInputOperationRetryAlias = ();
impl GetTeamTransfersListInput {
	/// Consumes the builder and constructs an Operation<[`GetTeamTransfersList`](crate::operation::GetTeamTransfersList)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetTeamTransfersList, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetTeamTransfersListInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_31 = &_input.team_id;
				let input_31 = input_31.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					},
				)?;
				let team_id = aws_smithy_http::label::fmt_string(input_31, false);
				if team_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/teams/{team_id}/billing/transfers",
					team_id = team_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetTeamTransfersListInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_32) = &_input.start_transfer_id {
					query.push_kv(
						"start_transfer_id",
						&aws_smithy_http::query::fmt_string(&inner_32),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetTeamTransfersListInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetTeamTransfersList::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetTeamTransfersList",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetTeamTransfersListInput`](crate::input::GetTeamTransfersListInput)
	pub fn builder() -> crate::input::get_team_transfers_list_input::Builder {
		crate::input::get_team_transfers_list_input::Builder::default()
	}
}

/// See [`InspectInput`](crate::input::InspectInput)
pub mod inspect_input {
	/// A builder for [`InspectInput`](crate::input::InspectInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`InspectInput`](crate::input::InspectInput)
		pub fn build(
			self,
		) -> std::result::Result<crate::input::InspectInput, aws_smithy_http::operation::BuildError>
		{
			Ok(crate::input::InspectInput {})
		}
	}
}
#[doc(hidden)]
pub type InspectInputOperationOutputAlias = crate::operation::Inspect;
#[doc(hidden)]
pub type InspectInputOperationRetryAlias = ();
impl InspectInput {
	/// Consumes the builder and constructs an Operation<[`Inspect`](crate::operation::Inspect)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::Inspect, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::InspectInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/auth/inspect").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::InspectInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op =
			aws_smithy_http::operation::Operation::new(request, crate::operation::Inspect::new())
				.with_metadata(aws_smithy_http::operation::Metadata::new(
					"Inspect",
					"CloudService",
				));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`InspectInput`](crate::input::InspectInput)
	pub fn builder() -> crate::input::inspect_input::Builder {
		crate::input::inspect_input::Builder::default()
	}
}

/// See [`ListGameBuildsInput`](crate::input::ListGameBuildsInput)
pub mod list_game_builds_input {
	/// A builder for [`ListGameBuildsInput`](crate::input::ListGameBuildsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ListGameBuildsInput`](crate::input::ListGameBuildsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListGameBuildsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListGameBuildsInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ListGameBuildsInputOperationOutputAlias = crate::operation::ListGameBuilds;
#[doc(hidden)]
pub type ListGameBuildsInputOperationRetryAlias = ();
impl ListGameBuildsInput {
	/// Consumes the builder and constructs an Operation<[`ListGameBuilds`](crate::operation::ListGameBuilds)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListGameBuilds, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListGameBuildsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_33 = &_input.game_id;
				let input_33 = input_33.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_33, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/builds", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListGameBuildsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListGameBuilds::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListGameBuilds",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListGameBuildsInput`](crate::input::ListGameBuildsInput)
	pub fn builder() -> crate::input::list_game_builds_input::Builder {
		crate::input::list_game_builds_input::Builder::default()
	}
}

/// See [`ListGameCdnSitesInput`](crate::input::ListGameCdnSitesInput)
pub mod list_game_cdn_sites_input {
	/// A builder for [`ListGameCdnSitesInput`](crate::input::ListGameCdnSitesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ListGameCdnSitesInput`](crate::input::ListGameCdnSitesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListGameCdnSitesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListGameCdnSitesInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ListGameCdnSitesInputOperationOutputAlias = crate::operation::ListGameCdnSites;
#[doc(hidden)]
pub type ListGameCdnSitesInputOperationRetryAlias = ();
impl ListGameCdnSitesInput {
	/// Consumes the builder and constructs an Operation<[`ListGameCdnSites`](crate::operation::ListGameCdnSites)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListGameCdnSites, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListGameCdnSitesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_34 = &_input.game_id;
				let input_34 = input_34.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_34, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/cdn/sites", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListGameCdnSitesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListGameCdnSites::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListGameCdnSites",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListGameCdnSitesInput`](crate::input::ListGameCdnSitesInput)
	pub fn builder() -> crate::input::list_game_cdn_sites_input::Builder {
		crate::input::list_game_cdn_sites_input::Builder::default()
	}
}

/// See [`ListNamespaceLobbiesInput`](crate::input::ListNamespaceLobbiesInput)
pub mod list_namespace_lobbies_input {
	/// A builder for [`ListNamespaceLobbiesInput`](crate::input::ListNamespaceLobbiesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) before_create_ts: std::option::Option<i64>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn before_create_ts(mut self, input: i64) -> Self {
			self.before_create_ts = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_before_create_ts(mut self, input: std::option::Option<i64>) -> Self {
			self.before_create_ts = input;
			self
		}
		/// Consumes the builder and constructs a [`ListNamespaceLobbiesInput`](crate::input::ListNamespaceLobbiesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListNamespaceLobbiesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListNamespaceLobbiesInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				before_create_ts: self.before_create_ts,
			})
		}
	}
}
#[doc(hidden)]
pub type ListNamespaceLobbiesInputOperationOutputAlias = crate::operation::ListNamespaceLobbies;
#[doc(hidden)]
pub type ListNamespaceLobbiesInputOperationRetryAlias = ();
impl ListNamespaceLobbiesInput {
	/// Consumes the builder and constructs an Operation<[`ListNamespaceLobbies`](crate::operation::ListNamespaceLobbies)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListNamespaceLobbies, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListNamespaceLobbiesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_35 = &_input.game_id;
				let input_35 = input_35.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_35, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_36 = &_input.namespace_id;
				let input_36 = input_36.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_36, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/logs/lobbies",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListNamespaceLobbiesInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_37) = &_input.before_create_ts {
					query.push_kv(
						"before_create_ts",
						aws_smithy_types::primitive::Encoder::from(*inner_37).encode(),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListNamespaceLobbiesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListNamespaceLobbies::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListNamespaceLobbies",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListNamespaceLobbiesInput`](crate::input::ListNamespaceLobbiesInput)
	pub fn builder() -> crate::input::list_namespace_lobbies_input::Builder {
		crate::input::list_namespace_lobbies_input::Builder::default()
	}
}

/// See [`RemoveNamespaceDomainInput`](crate::input::RemoveNamespaceDomainInput)
pub mod remove_namespace_domain_input {
	/// A builder for [`RemoveNamespaceDomainInput`](crate::input::RemoveNamespaceDomainInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) domain: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
			self.domain = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.domain = input;
			self
		}
		/// Consumes the builder and constructs a [`RemoveNamespaceDomainInput`](crate::input::RemoveNamespaceDomainInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::RemoveNamespaceDomainInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::RemoveNamespaceDomainInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				domain: self.domain,
			})
		}
	}
}
#[doc(hidden)]
pub type RemoveNamespaceDomainInputOperationOutputAlias = crate::operation::RemoveNamespaceDomain;
#[doc(hidden)]
pub type RemoveNamespaceDomainInputOperationRetryAlias = ();
impl RemoveNamespaceDomainInput {
	/// Consumes the builder and constructs an Operation<[`RemoveNamespaceDomain`](crate::operation::RemoveNamespaceDomain)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::RemoveNamespaceDomain, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::RemoveNamespaceDomainInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_38 = &_input.game_id;
				let input_38 = input_38.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_38, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_39 = &_input.namespace_id;
				let input_39 = input_39.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_39, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				let input_40 = &_input.domain;
				let input_40 = input_40.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "domain",
						details: "cannot be empty or unset",
					},
				)?;
				let domain = aws_smithy_http::label::fmt_string(input_40, false);
				if domain.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "domain",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/domains/{domain}",
					game_id = game_id,
					namespace_id = namespace_id,
					domain = domain
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::RemoveNamespaceDomainInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::RemoveNamespaceDomain::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"RemoveNamespaceDomain",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`RemoveNamespaceDomainInput`](crate::input::RemoveNamespaceDomainInput)
	pub fn builder() -> crate::input::remove_namespace_domain_input::Builder {
		crate::input::remove_namespace_domain_input::Builder::default()
	}
}

/// See [`TeamBillingCheckoutInput`](crate::input::TeamBillingCheckoutInput)
pub mod team_billing_checkout_input {
	/// A builder for [`TeamBillingCheckoutInput`](crate::input::TeamBillingCheckoutInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) team_id: std::option::Option<std::string::String>,
		pub(crate) amount: std::option::Option<i64>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.team_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.team_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn amount(mut self, input: i64) -> Self {
			self.amount = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_amount(mut self, input: std::option::Option<i64>) -> Self {
			self.amount = input;
			self
		}
		/// Consumes the builder and constructs a [`TeamBillingCheckoutInput`](crate::input::TeamBillingCheckoutInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::TeamBillingCheckoutInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::TeamBillingCheckoutInput {
				team_id: self.team_id,
				amount: self.amount,
			})
		}
	}
}
#[doc(hidden)]
pub type TeamBillingCheckoutInputOperationOutputAlias = crate::operation::TeamBillingCheckout;
#[doc(hidden)]
pub type TeamBillingCheckoutInputOperationRetryAlias = ();
impl TeamBillingCheckoutInput {
	/// Consumes the builder and constructs an Operation<[`TeamBillingCheckout`](crate::operation::TeamBillingCheckout)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::TeamBillingCheckout, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::TeamBillingCheckoutInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_41 = &_input.team_id;
				let input_41 = input_41.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					},
				)?;
				let team_id = aws_smithy_http::label::fmt_string(input_41, false);
				if team_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "team_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/teams/{team_id}/checkout", team_id = team_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::TeamBillingCheckoutInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_team_billing_checkout(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::TeamBillingCheckout::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"TeamBillingCheckout",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`TeamBillingCheckoutInput`](crate::input::TeamBillingCheckoutInput)
	pub fn builder() -> crate::input::team_billing_checkout_input::Builder {
		crate::input::team_billing_checkout_input::Builder::default()
	}
}

/// See [`ToggleNamespaceDomainPublicAuthInput`](crate::input::ToggleNamespaceDomainPublicAuthInput)
pub mod toggle_namespace_domain_public_auth_input {
	/// A builder for [`ToggleNamespaceDomainPublicAuthInput`](crate::input::ToggleNamespaceDomainPublicAuthInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) enabled: std::option::Option<bool>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn enabled(mut self, input: bool) -> Self {
			self.enabled = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
			self.enabled = input;
			self
		}
		/// Consumes the builder and constructs a [`ToggleNamespaceDomainPublicAuthInput`](crate::input::ToggleNamespaceDomainPublicAuthInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ToggleNamespaceDomainPublicAuthInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ToggleNamespaceDomainPublicAuthInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				enabled: self.enabled,
			})
		}
	}
}
#[doc(hidden)]
pub type ToggleNamespaceDomainPublicAuthInputOperationOutputAlias =
	crate::operation::ToggleNamespaceDomainPublicAuth;
#[doc(hidden)]
pub type ToggleNamespaceDomainPublicAuthInputOperationRetryAlias = ();
impl ToggleNamespaceDomainPublicAuthInput {
	/// Consumes the builder and constructs an Operation<[`ToggleNamespaceDomainPublicAuth`](crate::operation::ToggleNamespaceDomainPublicAuth)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::ToggleNamespaceDomainPublicAuth,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ToggleNamespaceDomainPublicAuthInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_42 = &_input.game_id;
				let input_42 = input_42.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_42, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_43 = &_input.namespace_id;
				let input_43 = input_43.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_43, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/domain-public-auth",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ToggleNamespaceDomainPublicAuthInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("PUT").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_toggle_namespace_domain_public_auth(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ToggleNamespaceDomainPublicAuth::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ToggleNamespaceDomainPublicAuth",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ToggleNamespaceDomainPublicAuthInput`](crate::input::ToggleNamespaceDomainPublicAuthInput)
	pub fn builder() -> crate::input::toggle_namespace_domain_public_auth_input::Builder {
		crate::input::toggle_namespace_domain_public_auth_input::Builder::default()
	}
}

/// See [`UpdateGameNamespaceMatchmakerConfigInput`](crate::input::UpdateGameNamespaceMatchmakerConfigInput)
pub mod update_game_namespace_matchmaker_config_input {
	/// A builder for [`UpdateGameNamespaceMatchmakerConfigInput`](crate::input::UpdateGameNamespaceMatchmakerConfigInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) lobby_count_max: std::option::Option<i32>,
		pub(crate) max_players: std::option::Option<i32>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn lobby_count_max(mut self, input: i32) -> Self {
			self.lobby_count_max = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_lobby_count_max(mut self, input: std::option::Option<i32>) -> Self {
			self.lobby_count_max = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn max_players(mut self, input: i32) -> Self {
			self.max_players = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_max_players(mut self, input: std::option::Option<i32>) -> Self {
			self.max_players = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateGameNamespaceMatchmakerConfigInput`](crate::input::UpdateGameNamespaceMatchmakerConfigInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateGameNamespaceMatchmakerConfigInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateGameNamespaceMatchmakerConfigInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				lobby_count_max: self.lobby_count_max,
				max_players: self.max_players,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateGameNamespaceMatchmakerConfigInputOperationOutputAlias =
	crate::operation::UpdateGameNamespaceMatchmakerConfig;
#[doc(hidden)]
pub type UpdateGameNamespaceMatchmakerConfigInputOperationRetryAlias = ();
impl UpdateGameNamespaceMatchmakerConfigInput {
	/// Consumes the builder and constructs an Operation<[`UpdateGameNamespaceMatchmakerConfig`](crate::operation::UpdateGameNamespaceMatchmakerConfig)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::UpdateGameNamespaceMatchmakerConfig,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateGameNamespaceMatchmakerConfigInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_44 = &_input.game_id;
				let input_44 = input_44.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_44, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_45 = &_input.namespace_id;
				let input_45 = input_45.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_45, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/mm-config",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateGameNamespaceMatchmakerConfigInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_game_namespace_matchmaker_config(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateGameNamespaceMatchmakerConfig::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateGameNamespaceMatchmakerConfig",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateGameNamespaceMatchmakerConfigInput`](crate::input::UpdateGameNamespaceMatchmakerConfigInput)
	pub fn builder() -> crate::input::update_game_namespace_matchmaker_config_input::Builder {
		crate::input::update_game_namespace_matchmaker_config_input::Builder::default()
	}
}

/// See [`UpdateGameNamespaceVersionInput`](crate::input::UpdateGameNamespaceVersionInput)
pub mod update_game_namespace_version_input {
	/// A builder for [`UpdateGameNamespaceVersionInput`](crate::input::UpdateGameNamespaceVersionInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) version_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.version_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.version_id = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateGameNamespaceVersionInput`](crate::input::UpdateGameNamespaceVersionInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateGameNamespaceVersionInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateGameNamespaceVersionInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				version_id: self.version_id,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateGameNamespaceVersionInputOperationOutputAlias =
	crate::operation::UpdateGameNamespaceVersion;
#[doc(hidden)]
pub type UpdateGameNamespaceVersionInputOperationRetryAlias = ();
impl UpdateGameNamespaceVersionInput {
	/// Consumes the builder and constructs an Operation<[`UpdateGameNamespaceVersion`](crate::operation::UpdateGameNamespaceVersion)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UpdateGameNamespaceVersion, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateGameNamespaceVersionInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_46 = &_input.game_id;
				let input_46 = input_46.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_46, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_47 = &_input.namespace_id;
				let input_47 = input_47.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_47, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/version",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateGameNamespaceVersionInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("PUT").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_game_namespace_version(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateGameNamespaceVersion::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateGameNamespaceVersion",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateGameNamespaceVersionInput`](crate::input::UpdateGameNamespaceVersionInput)
	pub fn builder() -> crate::input::update_game_namespace_version_input::Builder {
		crate::input::update_game_namespace_version_input::Builder::default()
	}
}

/// See [`UpdateNamespaceDomainInput`](crate::input::UpdateNamespaceDomainInput)
pub mod update_namespace_domain_input {
	/// A builder for [`UpdateNamespaceDomainInput`](crate::input::UpdateNamespaceDomainInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) domain: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
			self.domain = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.domain = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateNamespaceDomainInput`](crate::input::UpdateNamespaceDomainInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateNamespaceDomainInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateNamespaceDomainInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				domain: self.domain,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateNamespaceDomainInputOperationOutputAlias = crate::operation::UpdateNamespaceDomain;
#[doc(hidden)]
pub type UpdateNamespaceDomainInputOperationRetryAlias = ();
impl UpdateNamespaceDomainInput {
	/// Consumes the builder and constructs an Operation<[`UpdateNamespaceDomain`](crate::operation::UpdateNamespaceDomain)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UpdateNamespaceDomain, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateNamespaceDomainInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_48 = &_input.game_id;
				let input_48 = input_48.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_48, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_49 = &_input.namespace_id;
				let input_49 = input_49.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_49, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				let input_50 = &_input.domain;
				let input_50 = input_50.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "domain",
						details: "cannot be empty or unset",
					},
				)?;
				let domain = aws_smithy_http::label::fmt_string(input_50, false);
				if domain.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "domain",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/domains/{domain}",
					game_id = game_id,
					namespace_id = namespace_id,
					domain = domain
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateNamespaceDomainInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateNamespaceDomain::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateNamespaceDomain",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateNamespaceDomainInput`](crate::input::UpdateNamespaceDomainInput)
	pub fn builder() -> crate::input::update_namespace_domain_input::Builder {
		crate::input::update_namespace_domain_input::Builder::default()
	}
}

/// See [`ValidateGameInput`](crate::input::ValidateGameInput)
pub mod validate_game_input {
	/// A builder for [`ValidateGameInput`](crate::input::ValidateGameInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) name_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameInput`](crate::input::ValidateGameInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameInput {
				display_name: self.display_name,
				name_id: self.name_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameInputOperationOutputAlias = crate::operation::ValidateGame;
#[doc(hidden)]
pub type ValidateGameInputOperationRetryAlias = ();
impl ValidateGameInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGame`](crate::operation::ValidateGame)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateGame, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/games/validate").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_game(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGame::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGame",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameInput`](crate::input::ValidateGameInput)
	pub fn builder() -> crate::input::validate_game_input::Builder {
		crate::input::validate_game_input::Builder::default()
	}
}

/// See [`ValidateGameNamespaceInput`](crate::input::ValidateGameNamespaceInput)
pub mod validate_game_namespace_input {
	/// A builder for [`ValidateGameNamespaceInput`](crate::input::ValidateGameNamespaceInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) name_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameNamespaceInput`](crate::input::ValidateGameNamespaceInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameNamespaceInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameNamespaceInput {
				game_id: self.game_id,
				display_name: self.display_name,
				name_id: self.name_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameNamespaceInputOperationOutputAlias = crate::operation::ValidateGameNamespace;
#[doc(hidden)]
pub type ValidateGameNamespaceInputOperationRetryAlias = ();
impl ValidateGameNamespaceInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGameNamespace`](crate::operation::ValidateGameNamespace)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateGameNamespace, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameNamespaceInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_51 = &_input.game_id;
				let input_51 = input_51.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_51, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/validate",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameNamespaceInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_game_namespace(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGameNamespace::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGameNamespace",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameNamespaceInput`](crate::input::ValidateGameNamespaceInput)
	pub fn builder() -> crate::input::validate_game_namespace_input::Builder {
		crate::input::validate_game_namespace_input::Builder::default()
	}
}

/// See [`ValidateGameNamespaceMatchmakerConfigInput`](crate::input::ValidateGameNamespaceMatchmakerConfigInput)
pub mod validate_game_namespace_matchmaker_config_input {
	/// A builder for [`ValidateGameNamespaceMatchmakerConfigInput`](crate::input::ValidateGameNamespaceMatchmakerConfigInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) lobby_count_max: std::option::Option<i32>,
		pub(crate) max_players: std::option::Option<i32>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn lobby_count_max(mut self, input: i32) -> Self {
			self.lobby_count_max = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_lobby_count_max(mut self, input: std::option::Option<i32>) -> Self {
			self.lobby_count_max = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn max_players(mut self, input: i32) -> Self {
			self.max_players = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_max_players(mut self, input: std::option::Option<i32>) -> Self {
			self.max_players = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameNamespaceMatchmakerConfigInput`](crate::input::ValidateGameNamespaceMatchmakerConfigInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameNamespaceMatchmakerConfigInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameNamespaceMatchmakerConfigInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				lobby_count_max: self.lobby_count_max,
				max_players: self.max_players,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameNamespaceMatchmakerConfigInputOperationOutputAlias =
	crate::operation::ValidateGameNamespaceMatchmakerConfig;
#[doc(hidden)]
pub type ValidateGameNamespaceMatchmakerConfigInputOperationRetryAlias = ();
impl ValidateGameNamespaceMatchmakerConfigInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGameNamespaceMatchmakerConfig`](crate::operation::ValidateGameNamespaceMatchmakerConfig)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::ValidateGameNamespaceMatchmakerConfig,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameNamespaceMatchmakerConfigInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_52 = &_input.game_id;
				let input_52 = input_52.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_52, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_53 = &_input.namespace_id;
				let input_53 = input_53.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_53, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/mm-config/validate",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameNamespaceMatchmakerConfigInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_validate_game_namespace_matchmaker_config(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGameNamespaceMatchmakerConfig::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGameNamespaceMatchmakerConfig",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameNamespaceMatchmakerConfigInput`](crate::input::ValidateGameNamespaceMatchmakerConfigInput)
	pub fn builder() -> crate::input::validate_game_namespace_matchmaker_config_input::Builder {
		crate::input::validate_game_namespace_matchmaker_config_input::Builder::default()
	}
}

/// See [`ValidateGameNamespaceTokenDevelopmentInput`](crate::input::ValidateGameNamespaceTokenDevelopmentInput)
pub mod validate_game_namespace_token_development_input {
	/// A builder for [`ValidateGameNamespaceTokenDevelopmentInput`](crate::input::ValidateGameNamespaceTokenDevelopmentInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) hostname: std::option::Option<std::string::String>,
		pub(crate) lobby_ports:
			std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
			self.hostname = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.hostname = input;
			self
		}
		/// Appends an item to `lobby_ports`.
		///
		/// To override the contents of this collection use [`set_lobby_ports`](Self::set_lobby_ports).
		///
		pub fn lobby_ports(mut self, input: crate::model::LobbyGroupRuntimeDockerPort) -> Self {
			let mut v = self.lobby_ports.unwrap_or_default();
			v.push(input);
			self.lobby_ports = Some(v);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_lobby_ports(
			mut self,
			input: std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
		) -> Self {
			self.lobby_ports = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameNamespaceTokenDevelopmentInput`](crate::input::ValidateGameNamespaceTokenDevelopmentInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameNamespaceTokenDevelopmentInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameNamespaceTokenDevelopmentInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				hostname: self.hostname,
				lobby_ports: self.lobby_ports,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameNamespaceTokenDevelopmentInputOperationOutputAlias =
	crate::operation::ValidateGameNamespaceTokenDevelopment;
#[doc(hidden)]
pub type ValidateGameNamespaceTokenDevelopmentInputOperationRetryAlias = ();
impl ValidateGameNamespaceTokenDevelopmentInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGameNamespaceTokenDevelopment`](crate::operation::ValidateGameNamespaceTokenDevelopment)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::ValidateGameNamespaceTokenDevelopment,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameNamespaceTokenDevelopmentInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_54 = &_input.game_id;
				let input_54 = input_54.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_54, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_55 = &_input.namespace_id;
				let input_55 = input_55.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_55, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/tokens/development/validate",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameNamespaceTokenDevelopmentInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_validate_game_namespace_token_development(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGameNamespaceTokenDevelopment::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGameNamespaceTokenDevelopment",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameNamespaceTokenDevelopmentInput`](crate::input::ValidateGameNamespaceTokenDevelopmentInput)
	pub fn builder() -> crate::input::validate_game_namespace_token_development_input::Builder {
		crate::input::validate_game_namespace_token_development_input::Builder::default()
	}
}

/// See [`ValidateGameVersionInput`](crate::input::ValidateGameVersionInput)
pub mod validate_game_version_input {
	/// A builder for [`ValidateGameVersionInput`](crate::input::ValidateGameVersionInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) config: std::option::Option<crate::model::CloudVersionConfig>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn config(mut self, input: crate::model::CloudVersionConfig) -> Self {
			self.config = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_config(
			mut self,
			input: std::option::Option<crate::model::CloudVersionConfig>,
		) -> Self {
			self.config = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameVersionInput`](crate::input::ValidateGameVersionInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameVersionInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameVersionInput {
				game_id: self.game_id,
				display_name: self.display_name,
				config: self.config,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameVersionInputOperationOutputAlias = crate::operation::ValidateGameVersion;
#[doc(hidden)]
pub type ValidateGameVersionInputOperationRetryAlias = ();
impl ValidateGameVersionInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGameVersion`](crate::operation::ValidateGameVersion)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateGameVersion, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameVersionInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_56 = &_input.game_id;
				let input_56 = input_56.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_56, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/versions/validate",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameVersionInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_game_version(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGameVersion::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGameVersion",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameVersionInput`](crate::input::ValidateGameVersionInput)
	pub fn builder() -> crate::input::validate_game_version_input::Builder {
		crate::input::validate_game_version_input::Builder::default()
	}
}

/// See [`ValidateTeamInput`](crate::input::ValidateTeamInput)
pub mod validate_team_input {
	/// A builder for [`ValidateTeamInput`](crate::input::ValidateTeamInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) display_name: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateTeamInput`](crate::input::ValidateTeamInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateTeamInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateTeamInput {
				display_name: self.display_name,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateTeamInputOperationOutputAlias = crate::operation::ValidateTeam;
#[doc(hidden)]
pub type ValidateTeamInputOperationRetryAlias = ();
impl ValidateTeamInput {
	/// Consumes the builder and constructs an Operation<[`ValidateTeam`](crate::operation::ValidateTeam)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateTeam, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateTeamInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/teams/validate").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateTeamInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_team(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateTeam::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateTeam",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateTeamInput`](crate::input::ValidateTeamInput)
	pub fn builder() -> crate::input::validate_team_input::Builder {
		crate::input::validate_team_input::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRayPerfLogsInput {
	#[allow(missing_docs)] // documentation missing in model
	pub ray_id: std::option::Option<std::string::String>,
}
impl GetRayPerfLogsInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn ray_id(&self) -> std::option::Option<&str> {
		self.ray_id.as_deref()
	}
}
impl std::fmt::Debug for GetRayPerfLogsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetRayPerfLogsInput");
		formatter.field("ray_id", &self.ray_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateTeamInput {
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
}
impl ValidateTeamInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
}
impl std::fmt::Debug for ValidateTeamInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateTeamInput");
		formatter.field("display_name", &self.display_name);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TeamBillingCheckoutInput {
	#[allow(missing_docs)] // documentation missing in model
	pub team_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub amount: std::option::Option<i64>,
}
impl TeamBillingCheckoutInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn team_id(&self) -> std::option::Option<&str> {
		self.team_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn amount(&self) -> std::option::Option<i64> {
		self.amount
	}
}
impl std::fmt::Debug for TeamBillingCheckoutInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("TeamBillingCheckoutInput");
		formatter.field("team_id", &self.team_id);
		formatter.field("amount", &self.amount);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConvertTeamInput {
	#[allow(missing_docs)] // documentation missing in model
	pub team_id: std::option::Option<std::string::String>,
}
impl ConvertTeamInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn team_id(&self) -> std::option::Option<&str> {
		self.team_id.as_deref()
	}
}
impl std::fmt::Debug for ConvertTeamInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ConvertTeamInput");
		formatter.field("team_id", &self.team_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTeamTransfersListInput {
	#[allow(missing_docs)] // documentation missing in model
	pub team_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub start_transfer_id: std::option::Option<std::string::String>,
}
impl GetTeamTransfersListInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn team_id(&self) -> std::option::Option<&str> {
		self.team_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn start_transfer_id(&self) -> std::option::Option<&str> {
		self.start_transfer_id.as_deref()
	}
}
impl std::fmt::Debug for GetTeamTransfersListInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetTeamTransfersListInput");
		formatter.field("team_id", &self.team_id);
		formatter.field("start_transfer_id", &self.start_transfer_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTeamPaymentsListInput {
	#[allow(missing_docs)] // documentation missing in model
	pub team_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub start_payment_id: std::option::Option<std::string::String>,
}
impl GetTeamPaymentsListInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn team_id(&self) -> std::option::Option<&str> {
		self.team_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn start_payment_id(&self) -> std::option::Option<&str> {
		self.start_payment_id.as_deref()
	}
}
impl std::fmt::Debug for GetTeamPaymentsListInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetTeamPaymentsListInput");
		formatter.field("team_id", &self.team_id);
		formatter.field("start_payment_id", &self.start_payment_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTeamBillingInput {
	#[allow(missing_docs)] // documentation missing in model
	pub team_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub query_start: std::option::Option<i64>,
	#[allow(missing_docs)] // documentation missing in model
	pub query_end: std::option::Option<i64>,
}
impl GetTeamBillingInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn team_id(&self) -> std::option::Option<&str> {
		self.team_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn query_start(&self) -> std::option::Option<i64> {
		self.query_start
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn query_end(&self) -> std::option::Option<i64> {
		self.query_end
	}
}
impl std::fmt::Debug for GetTeamBillingInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetTeamBillingInput");
		formatter.field("team_id", &self.team_id);
		formatter.field("query_start", &self.query_start);
		formatter.field("query_end", &self.query_end);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRegionTiersInput {}
impl std::fmt::Debug for GetRegionTiersInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetRegionTiersInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportMatchmakerLobbyHistoryInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub query_start: std::option::Option<i64>,
	#[allow(missing_docs)] // documentation missing in model
	pub query_end: std::option::Option<i64>,
}
impl ExportMatchmakerLobbyHistoryInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn query_start(&self) -> std::option::Option<i64> {
		self.query_start
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn query_end(&self) -> std::option::Option<i64> {
		self.query_end
	}
}
impl std::fmt::Debug for ExportMatchmakerLobbyHistoryInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ExportMatchmakerLobbyHistoryInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("query_start", &self.query_start);
		formatter.field("query_end", &self.query_end);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMatchmakerLobbyInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub lobby_id: std::option::Option<std::string::String>,
}
impl DeleteMatchmakerLobbyInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
}
impl std::fmt::Debug for DeleteMatchmakerLobbyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("DeleteMatchmakerLobbyInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("lobby_id", &self.lobby_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameCdnSiteInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub files: std::option::Option<std::vec::Vec<crate::model::UploadPrepareFile>>,
}
impl CreateGameCdnSiteInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn files(&self) -> std::option::Option<&[crate::model::UploadPrepareFile]> {
		self.files.as_deref()
	}
}
impl std::fmt::Debug for CreateGameCdnSiteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameCdnSiteInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("files", &self.files);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGameCdnSitesInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
}
impl ListGameCdnSitesInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for ListGameCdnSitesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListGameCdnSitesInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameBuildInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub image_tag: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub image_file: std::option::Option<crate::model::UploadPrepareFile>,
}
impl CreateGameBuildInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn image_tag(&self) -> std::option::Option<&str> {
		self.image_tag.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn image_file(&self) -> std::option::Option<&crate::model::UploadPrepareFile> {
		self.image_file.as_ref()
	}
}
impl std::fmt::Debug for CreateGameBuildInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameBuildInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("image_tag", &self.image_tag);
		formatter.field("image_file", &self.image_file);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGameBuildsInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
}
impl ListGameBuildsInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for ListGameBuildsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListGameBuildsInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCloudTokenInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
}
impl CreateCloudTokenInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for CreateCloudTokenInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateCloudTokenInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNamespaceLobbyInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub lobby_id: std::option::Option<std::string::String>,
}
impl GetNamespaceLobbyInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
}
impl std::fmt::Debug for GetNamespaceLobbyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetNamespaceLobbyInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("lobby_id", &self.lobby_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNamespaceLobbiesInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub before_create_ts: std::option::Option<i64>,
}
impl ListNamespaceLobbiesInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn before_create_ts(&self) -> std::option::Option<i64> {
		self.before_create_ts
	}
}
impl std::fmt::Debug for ListNamespaceLobbiesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListNamespaceLobbiesInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("before_create_ts", &self.before_create_ts);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNamespaceAnalyticsMatchmakerLiveInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
}
impl GetNamespaceAnalyticsMatchmakerLiveInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
}
impl std::fmt::Debug for GetNamespaceAnalyticsMatchmakerLiveInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetNamespaceAnalyticsMatchmakerLiveInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameNamespaceMatchmakerConfigInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub lobby_count_max: std::option::Option<i32>,
	#[allow(missing_docs)] // documentation missing in model
	pub max_players: std::option::Option<i32>,
}
impl ValidateGameNamespaceMatchmakerConfigInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn lobby_count_max(&self) -> std::option::Option<i32> {
		self.lobby_count_max
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn max_players(&self) -> std::option::Option<i32> {
		self.max_players
	}
}
impl std::fmt::Debug for ValidateGameNamespaceMatchmakerConfigInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameNamespaceMatchmakerConfigInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("lobby_count_max", &self.lobby_count_max);
		formatter.field("max_players", &self.max_players);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameNamespaceTokenDevelopmentInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub hostname: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub lobby_ports: std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
}
impl ValidateGameNamespaceTokenDevelopmentInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn hostname(&self) -> std::option::Option<&str> {
		self.hostname.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn lobby_ports(&self) -> std::option::Option<&[crate::model::LobbyGroupRuntimeDockerPort]> {
		self.lobby_ports.as_deref()
	}
}
impl std::fmt::Debug for ValidateGameNamespaceTokenDevelopmentInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameNamespaceTokenDevelopmentInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("hostname", &self.hostname);
		formatter.field("lobby_ports", &self.lobby_ports);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameNamespaceInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub name_id: std::option::Option<std::string::String>,
}
impl ValidateGameNamespaceInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
}
impl std::fmt::Debug for ValidateGameNamespaceInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameNamespaceInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("name_id", &self.name_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGameNamespaceMatchmakerConfigInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub lobby_count_max: std::option::Option<i32>,
	#[allow(missing_docs)] // documentation missing in model
	pub max_players: std::option::Option<i32>,
}
impl UpdateGameNamespaceMatchmakerConfigInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn lobby_count_max(&self) -> std::option::Option<i32> {
		self.lobby_count_max
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn max_players(&self) -> std::option::Option<i32> {
		self.max_players
	}
}
impl std::fmt::Debug for UpdateGameNamespaceMatchmakerConfigInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateGameNamespaceMatchmakerConfigInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("lobby_count_max", &self.lobby_count_max);
		formatter.field("max_players", &self.max_players);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ToggleNamespaceDomainPublicAuthInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub enabled: std::option::Option<bool>,
}
impl ToggleNamespaceDomainPublicAuthInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn enabled(&self) -> std::option::Option<bool> {
		self.enabled
	}
}
impl std::fmt::Debug for ToggleNamespaceDomainPublicAuthInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ToggleNamespaceDomainPublicAuthInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("enabled", &self.enabled);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveNamespaceDomainInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub domain: std::option::Option<std::string::String>,
}
impl RemoveNamespaceDomainInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn domain(&self) -> std::option::Option<&str> {
		self.domain.as_deref()
	}
}
impl std::fmt::Debug for RemoveNamespaceDomainInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RemoveNamespaceDomainInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("domain", &self.domain);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateNamespaceDomainInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub domain: std::option::Option<std::string::String>,
}
impl UpdateNamespaceDomainInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn domain(&self) -> std::option::Option<&str> {
		self.domain.as_deref()
	}
}
impl std::fmt::Debug for UpdateNamespaceDomainInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateNamespaceDomainInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("domain", &self.domain);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameNamespaceTokenDevelopmentInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub hostname: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub lobby_ports: std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
}
impl CreateGameNamespaceTokenDevelopmentInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn hostname(&self) -> std::option::Option<&str> {
		self.hostname.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn lobby_ports(&self) -> std::option::Option<&[crate::model::LobbyGroupRuntimeDockerPort]> {
		self.lobby_ports.as_deref()
	}
}
impl std::fmt::Debug for CreateGameNamespaceTokenDevelopmentInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameNamespaceTokenDevelopmentInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("hostname", &self.hostname);
		formatter.field("lobby_ports", &self.lobby_ports);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameNamespaceTokenPublicInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
}
impl CreateGameNamespaceTokenPublicInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
}
impl std::fmt::Debug for CreateGameNamespaceTokenPublicInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameNamespaceTokenPublicInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGameNamespaceVersionInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub version_id: std::option::Option<std::string::String>,
}
impl UpdateGameNamespaceVersionInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn version_id(&self) -> std::option::Option<&str> {
		self.version_id.as_deref()
	}
}
impl std::fmt::Debug for UpdateGameNamespaceVersionInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateGameNamespaceVersionInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("version_id", &self.version_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameNamespaceByIdInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub namespace_id: std::option::Option<std::string::String>,
}
impl GetGameNamespaceByIdInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
}
impl std::fmt::Debug for GetGameNamespaceByIdInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameNamespaceByIdInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameNamespaceInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub version_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub name_id: std::option::Option<std::string::String>,
}
impl CreateGameNamespaceInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn version_id(&self) -> std::option::Option<&str> {
		self.version_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
}
impl std::fmt::Debug for CreateGameNamespaceInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameNamespaceInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("version_id", &self.version_id);
		formatter.field("name_id", &self.name_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameVersionInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub config: std::option::Option<crate::model::CloudVersionConfig>,
}
impl ValidateGameVersionInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn config(&self) -> std::option::Option<&crate::model::CloudVersionConfig> {
		self.config.as_ref()
	}
}
impl std::fmt::Debug for ValidateGameVersionInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameVersionInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("config", &self.config);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameVersionByIdInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub version_id: std::option::Option<std::string::String>,
}
impl GetGameVersionByIdInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn version_id(&self) -> std::option::Option<&str> {
		self.version_id.as_deref()
	}
}
impl std::fmt::Debug for GetGameVersionByIdInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameVersionByIdInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("version_id", &self.version_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameVersionInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub config: std::option::Option<crate::model::CloudVersionConfig>,
}
impl CreateGameVersionInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn config(&self) -> std::option::Option<&crate::model::CloudVersionConfig> {
		self.config.as_ref()
	}
}
impl std::fmt::Debug for CreateGameVersionInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameVersionInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("config", &self.config);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameInput {
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub name_id: std::option::Option<std::string::String>,
}
impl ValidateGameInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
}
impl std::fmt::Debug for ValidateGameInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameInput");
		formatter.field("display_name", &self.display_name);
		formatter.field("name_id", &self.name_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameByIdInput {
	#[allow(missing_docs)] // documentation missing in model
	pub game_id: std::option::Option<std::string::String>,
}
impl GetGameByIdInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for GetGameByIdInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameByIdInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameInput {
	#[allow(missing_docs)] // documentation missing in model
	pub name_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub display_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub developer_team_id: std::option::Option<std::string::String>,
}
impl CreateGameInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn developer_team_id(&self) -> std::option::Option<&str> {
		self.developer_team_id.as_deref()
	}
}
impl std::fmt::Debug for CreateGameInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameInput");
		formatter.field("name_id", &self.name_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("developer_team_id", &self.developer_team_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGamesInput {}
impl std::fmt::Debug for GetGamesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGamesInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompleteUploadInput {
	#[allow(missing_docs)] // documentation missing in model
	pub upload_id: std::option::Option<std::string::String>,
}
impl CompleteUploadInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn upload_id(&self) -> std::option::Option<&str> {
		self.upload_id.as_deref()
	}
}
impl std::fmt::Debug for CompleteUploadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CompleteUploadInput");
		formatter.field("upload_id", &self.upload_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InspectInput {}
impl std::fmt::Debug for InspectInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("InspectInput");
		formatter.finish()
	}
}
