/*
 * Rivet Cloud
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `create_cloud_token`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCloudTokenError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameBuildError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_cdn_site`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameCdnSiteError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_namespace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameNamespaceError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_namespace_token_development`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameNamespaceTokenDevelopmentError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_namespace_token_public`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameNamespaceTokenPublicError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameVersionError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_game_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGameByIdError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_game_namespace_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGameNamespaceByIdError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_game_version_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGameVersionByIdError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_games`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGamesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_cdn_sites`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCdnSitesError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_game_builds`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGameBuildsError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_game_namespace_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGameNamespaceVersionError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}


pub async fn create_cloud_token(configuration: &configuration::Configuration, game_id: &str, body: serde_json::Value) -> Result<crate::models::InlineResponse2007, Error<CreateCloudTokenError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/tokens/cloud", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateCloudTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game(configuration: &configuration::Configuration, inline_object: crate::models::InlineObject) -> Result<crate::models::InlineResponse200AgentGameCloud, Error<CreateGameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_build(configuration: &configuration::Configuration, game_id: &str, inline_object6: crate::models::InlineObject6) -> Result<crate::models::InlineResponse20011, Error<CreateGameBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/builds", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object6);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_cdn_site(configuration: &configuration::Configuration, game_id: &str, inline_object5: crate::models::InlineObject5) -> Result<crate::models::InlineResponse2009, Error<CreateGameCdnSiteError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/cdn/sites", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object5);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameCdnSiteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_namespace(configuration: &configuration::Configuration, game_id: &str, inline_object2: crate::models::InlineObject2) -> Result<crate::models::InlineResponse2005, Error<CreateGameNamespaceError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameNamespaceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_namespace_token_development(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str, inline_object4: crate::models::InlineObject4) -> Result<crate::models::InlineResponse2007, Error<CreateGameNamespaceTokenDevelopmentError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/tokens/development", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object4);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameNamespaceTokenDevelopmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_namespace_token_public(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str, body: serde_json::Value) -> Result<crate::models::InlineResponse2007, Error<CreateGameNamespaceTokenPublicError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/tokens/public", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameNamespaceTokenPublicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_version(configuration: &configuration::Configuration, game_id: &str, inline_object1: crate::models::InlineObject1) -> Result<crate::models::InlineResponse2003, Error<CreateGameVersionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/versions", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object1);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_game_by_id(configuration: &configuration::Configuration, game_id: &str) -> Result<crate::models::InlineResponse2002, Error<GetGameByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGameByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_game_namespace_by_id(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str) -> Result<crate::models::InlineResponse2006, Error<GetGameNamespaceByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGameNamespaceByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_game_version_by_id(configuration: &configuration::Configuration, game_id: &str, version_id: &str) -> Result<crate::models::InlineResponse2004, Error<GetGameVersionByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/versions/{version_id}", configuration.base_path, game_id=game_id, version_id=version_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGameVersionByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_games(configuration: &configuration::Configuration, ) -> Result<crate::models::InlineResponse2001, Error<GetGamesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGamesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_cdn_sites(configuration: &configuration::Configuration, game_id: &str) -> Result<crate::models::InlineResponse2008, Error<ListCdnSitesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/cdn/sites", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListCdnSitesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_game_builds(configuration: &configuration::Configuration, game_id: &str) -> Result<crate::models::InlineResponse20010, Error<ListGameBuildsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/builds", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListGameBuildsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_game_namespace_version(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str, inline_object3: crate::models::InlineObject3) -> Result<crate::models::InlineObject3, Error<UpdateGameNamespaceVersionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/version", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object3);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateGameNamespaceVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

