/*
 * Rivet Cloud
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `convert_team`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConvertTeamError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_cloud_token`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCloudTokenError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameBuildError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_cdn_site`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameCdnSiteError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_namespace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameNamespaceError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_namespace_token_development`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameNamespaceTokenDevelopmentError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_namespace_token_public`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameNamespaceTokenPublicError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_game_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGameVersionError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_matchmaker_lobby`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMatchmakerLobbyError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_game_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGameByIdError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_game_namespace_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGameNamespaceByIdError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_game_version_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGameVersionByIdError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_games`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGamesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_namespace_analytics_matchmaker_live`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNamespaceAnalyticsMatchmakerLiveError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_team_billing`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamBillingError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_team_payments_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamPaymentsListError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_cdn_sites`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCdnSitesError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_game_builds`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGameBuildsError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_namespace_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveNamespaceDomainError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `team_billing_checkout`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamBillingCheckoutError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_game_namespace_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGameNamespaceVersionError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_namespace_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateNamespaceDomainError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `validate_game`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateGameError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `validate_game_namespace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateGameNamespaceError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `validate_game_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateGameVersionError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `validate_team`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateTeamError {
    Status400(crate::models::ResponseError),
    Status401(crate::models::ResponseError),
    Status403(crate::models::ResponseError),
    Status404(crate::models::ResponseError),
    Status500(crate::models::ResponseError),
    UnknownValue(serde_json::Value),
}


pub async fn convert_team(configuration: &configuration::Configuration, team_id: &str) -> Result<(), Error<ConvertTeamError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/teams/{team_id}/convert", configuration.base_path, team_id=team_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ConvertTeamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_cloud_token(configuration: &configuration::Configuration, game_id: &str, body: serde_json::Value) -> Result<crate::models::InlineResponse2007, Error<CreateCloudTokenError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/tokens/cloud", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateCloudTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game(configuration: &configuration::Configuration, inline_object: crate::models::InlineObject) -> Result<crate::models::InlineResponse200AgentGameCloud, Error<CreateGameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_build(configuration: &configuration::Configuration, game_id: &str, inline_object6: crate::models::InlineObject6) -> Result<crate::models::InlineResponse20012, Error<CreateGameBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/builds", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object6);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_cdn_site(configuration: &configuration::Configuration, game_id: &str, inline_object5: crate::models::InlineObject5) -> Result<crate::models::InlineResponse20010, Error<CreateGameCdnSiteError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/cdn/sites", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object5);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameCdnSiteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_namespace(configuration: &configuration::Configuration, game_id: &str, inline_object2: crate::models::InlineObject2) -> Result<crate::models::InlineResponse2005, Error<CreateGameNamespaceError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameNamespaceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_namespace_token_development(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str, inline_object4: crate::models::InlineObject4) -> Result<crate::models::InlineResponse2007, Error<CreateGameNamespaceTokenDevelopmentError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/tokens/development", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object4);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameNamespaceTokenDevelopmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_namespace_token_public(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str, body: serde_json::Value) -> Result<crate::models::InlineResponse2007, Error<CreateGameNamespaceTokenPublicError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/tokens/public", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameNamespaceTokenPublicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_game_version(configuration: &configuration::Configuration, game_id: &str, inline_object1: crate::models::InlineObject1) -> Result<crate::models::InlineResponse2003, Error<CreateGameVersionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/versions", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object1);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateGameVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_matchmaker_lobby(configuration: &configuration::Configuration, game_id: &str, lobby_id: &str) -> Result<crate::models::InlineResponse20013, Error<DeleteMatchmakerLobbyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/matchmaker/lobbies/{lobby_id}", configuration.base_path, game_id=game_id, lobby_id=lobby_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteMatchmakerLobbyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_game_by_id(configuration: &configuration::Configuration, game_id: &str) -> Result<crate::models::InlineResponse2002, Error<GetGameByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGameByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_game_namespace_by_id(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str) -> Result<crate::models::InlineResponse2006, Error<GetGameNamespaceByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGameNamespaceByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_game_version_by_id(configuration: &configuration::Configuration, game_id: &str, version_id: &str) -> Result<crate::models::InlineResponse2004, Error<GetGameVersionByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/versions/{version_id}", configuration.base_path, game_id=game_id, version_id=version_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGameVersionByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_games(configuration: &configuration::Configuration, ) -> Result<crate::models::InlineResponse2001, Error<GetGamesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGamesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_namespace_analytics_matchmaker_live(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str) -> Result<crate::models::InlineResponse2008, Error<GetNamespaceAnalyticsMatchmakerLiveError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/analytics/matchmaker/live", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetNamespaceAnalyticsMatchmakerLiveError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_team_billing(configuration: &configuration::Configuration, team_id: &str, inline_object7: crate::models::InlineObject7) -> Result<crate::models::InlineResponse20014, Error<GetTeamBillingError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/teams/{team_id}/billing", configuration.base_path, team_id=team_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object7);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTeamBillingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_team_payments_list(configuration: &configuration::Configuration, team_id: &str, start_payment_id: Option<&str>) -> Result<crate::models::InlineResponse20015, Error<GetTeamPaymentsListError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/teams/{team_id}/billing/payments", configuration.base_path, team_id=team_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start_payment_id {
        local_var_req_builder = local_var_req_builder.query(&[("start_payment_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTeamPaymentsListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_cdn_sites(configuration: &configuration::Configuration, game_id: &str) -> Result<crate::models::InlineResponse2009, Error<ListCdnSitesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/cdn/sites", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListCdnSitesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_game_builds(configuration: &configuration::Configuration, game_id: &str) -> Result<crate::models::InlineResponse20011, Error<ListGameBuildsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/builds", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListGameBuildsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn remove_namespace_domain(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str, domain: &str) -> Result<(), Error<RemoveNamespaceDomainError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/domains/{domain}", configuration.base_path, game_id=game_id, namespace_id=namespace_id, domain=crate::apis::urlencode(domain));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<RemoveNamespaceDomainError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_billing_checkout(configuration: &configuration::Configuration, team_id: &str, inline_object8: crate::models::InlineObject8) -> Result<crate::models::InlineResponse20016, Error<TeamBillingCheckoutError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/teams/{team_id}/checkout", configuration.base_path, team_id=team_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object8);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamBillingCheckoutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_game_namespace_version(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str, inline_object3: crate::models::InlineObject3) -> Result<crate::models::InlineObject3, Error<UpdateGameNamespaceVersionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/version", configuration.base_path, game_id=game_id, namespace_id=namespace_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object3);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateGameNamespaceVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_namespace_domain(configuration: &configuration::Configuration, game_id: &str, namespace_id: &str, domain: &str) -> Result<(), Error<UpdateNamespaceDomainError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespaces/{namespace_id}/domains/{domain}", configuration.base_path, game_id=game_id, namespace_id=namespace_id, domain=crate::apis::urlencode(domain));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UpdateNamespaceDomainError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validate_game(configuration: &configuration::Configuration, inline_object11: crate::models::InlineObject11) -> Result<crate::models::InlineResponse20017, Error<ValidateGameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/validate", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object11);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidateGameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validate_game_namespace(configuration: &configuration::Configuration, game_id: &str, inline_object10: crate::models::InlineObject10) -> Result<crate::models::InlineResponse20017, Error<ValidateGameNamespaceError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/namespace/validate", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object10);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidateGameNamespaceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validate_game_version(configuration: &configuration::Configuration, game_id: &str, inline_object9: crate::models::InlineObject9) -> Result<crate::models::InlineResponse20017, Error<ValidateGameVersionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/games/{game_id}/version/validate", configuration.base_path, game_id=game_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object9);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidateGameVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validate_team(configuration: &configuration::Configuration, inline_object12: crate::models::InlineObject12) -> Result<crate::models::InlineResponse20017, Error<ValidateTeamError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/teams/validate", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object12);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidateTeamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

